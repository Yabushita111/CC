{"ast":null,"code":"/* eslint-disable */ // MIT License:\n//\n// Copyright (c) 2010-2012, Joe Walnes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/**\n * This behaves like a WebSocket in every way, except if it fails to connect,\n * or it gets disconnected, it will repeatedly poll until it successfully connects\n * again.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * The event stream will typically look like:\n *  onconnecting\n *  onopen\n *  onmessage\n *  onmessage\n *  onclose // lost connection\n *  onconnecting\n *  onopen  // sometime later...\n *  onmessage\n *  onmessage\n *  etc...\n *\n * It is API compatible with the standard WebSocket API, apart from the following members:\n *\n * - `bufferedAmount`\n * - `extensions`\n * - `binaryType`\n *\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\n * - Joe Walnes\n *\n * Syntax\n * ======\n * var socket = new ReconnectingWebSocket(url, protocols, options);\n *\n * Parameters\n * ==========\n * url - The url you are connecting to.\n * protocols - Optional string or array of protocols.\n * options - See below\n *\n * Options\n * =======\n * Options can either be passed upon instantiation or set after instantiation:\n *\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\n *\n * or\n *\n * var socket = new ReconnectingWebSocket(url);\n * socket.debug = true;\n * socket.reconnectInterval = 4000;\n *\n * debug\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\n *\n * automaticOpen\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n *\n * reconnectInterval\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\n *\n * maxReconnectInterval\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\n *\n * reconnectDecay\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\n *\n * timeoutInterval\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\n *\n */(function(global,factory){if(typeof define===\"function\"&&define.amd){define([],factory);}else if(typeof module!==\"undefined\"&&module.exports){module.exports=factory();}else{global.ReconnectingWebSocket=factory();}})(this,function(){if(!(\"WebSocket\"in window)){return;}function ReconnectingWebSocket(url,protocols,options){// Default settings\nvar settings={/** Whether this instance should log debug messages. */debug:false,/** Whether or not the websocket should attempt to connect immediately upon instantiation. */automaticOpen:true,/** The number of milliseconds to delay before attempting to reconnect. */reconnectInterval:1000,/** The maximum number of milliseconds to delay a reconnection attempt. */maxReconnectInterval:30000,/** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */reconnectDecay:1.5,/** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */timeoutInterval:2000,/** The maximum number of reconnection attempts to make. Unlimited if null. */maxReconnectAttempts:null,/** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */binaryType:\"blob\"};if(!options){options={};}// Overwrite and define settings with options if they exist.\nfor(var key in settings){if(typeof options[key]!==\"undefined\"){this[key]=options[key];}else{this[key]=settings[key];}}// These should be treated as read-only properties\n/** The URL as resolved by the constructor. This is always an absolute URL. Read only. */this.url=url;/** The number of attempted reconnects since starting, or the last successful connection. Read only. */this.reconnectAttempts=0;/**\n     * The current state of the connection.\n     * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\n     * Read only.\n     */this.readyState=WebSocket.CONNECTING;/**\n     * A string indicating the name of the sub-protocol the server selected; this will be one of\n     * the strings specified in the protocols parameter when creating the WebSocket object.\n     * Read only.\n     */this.protocol=null;// Private state variables\nvar self=this;var ws;var forcedClose=false;var timedOut=false;var eventTarget=document.createElement(\"div\");// Wire up \"on*\" properties as event handlers\neventTarget.addEventListener(\"open\",function(event){self.onopen(event);});eventTarget.addEventListener(\"close\",function(event){self.onclose(event);});eventTarget.addEventListener(\"connecting\",function(event){self.onconnecting(event);});eventTarget.addEventListener(\"message\",function(event){self.onmessage(event);});eventTarget.addEventListener(\"error\",function(event){self.onerror(event);});// Expose the API required by EventTarget\nthis.addEventListener=eventTarget.addEventListener.bind(eventTarget);this.removeEventListener=eventTarget.removeEventListener.bind(eventTarget);this.dispatchEvent=eventTarget.dispatchEvent.bind(eventTarget);/**\n     * This function generates an event that is compatible with standard\n     * compliant browsers and IE9 - IE11\n     *\n     * This will prevent the error:\n     * Object doesn't support this action\n     *\n     * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\n     * @param s String The name that the event should use\n     * @param args Object an optional object that the event will use\n     */function generateEvent(s,args){var evt=document.createEvent(\"CustomEvent\");evt.initCustomEvent(s,false,false,args);return evt;}this.open=function(reconnectAttempt){ws=new WebSocket(self.url,protocols||[]);ws.binaryType=this.binaryType;if(reconnectAttempt){if(this.maxReconnectAttempts&&this.reconnectAttempts>this.maxReconnectAttempts){return;}}else{eventTarget.dispatchEvent(generateEvent(\"connecting\"));this.reconnectAttempts=0;}if(self.debug||ReconnectingWebSocket.debugAll){console.debug(\"ReconnectingWebSocket\",\"attempt-connect\",self.url);}var localWs=ws;var timeout=setTimeout(function(){if(self.debug||ReconnectingWebSocket.debugAll){console.debug(\"ReconnectingWebSocket\",\"connection-timeout\",self.url);}timedOut=true;localWs.close();timedOut=false;},self.timeoutInterval);ws.onopen=function(event){clearTimeout(timeout);if(self.debug||ReconnectingWebSocket.debugAll){console.debug(\"ReconnectingWebSocket\",\"onopen\",self.url);}self.protocol=ws.protocol;self.readyState=WebSocket.OPEN;self.reconnectAttempts=0;var e=generateEvent(\"open\");e.isReconnect=reconnectAttempt;reconnectAttempt=false;eventTarget.dispatchEvent(e);};ws.onclose=function(event){clearTimeout(timeout);ws=null;if(forcedClose){self.readyState=WebSocket.CLOSED;eventTarget.dispatchEvent(generateEvent(\"close\"));}else{self.readyState=WebSocket.CONNECTING;var e=generateEvent(\"connecting\");e.code=event.code;e.reason=event.reason;e.wasClean=event.wasClean;eventTarget.dispatchEvent(e);if(!reconnectAttempt&&!timedOut){if(self.debug||ReconnectingWebSocket.debugAll){console.debug(\"ReconnectingWebSocket\",\"onclose\",self.url);}eventTarget.dispatchEvent(generateEvent(\"close\"));}var timeout=self.reconnectInterval*Math.pow(self.reconnectDecay,self.reconnectAttempts);setTimeout(function(){self.reconnectAttempts++;self.open(true);},timeout>self.maxReconnectInterval?self.maxReconnectInterval:timeout);}};ws.onmessage=function(event){if(self.debug||ReconnectingWebSocket.debugAll){console.debug(\"ReconnectingWebSocket\",\"onmessage\",self.url,event.data);}var e=generateEvent(\"message\");e.data=event.data;eventTarget.dispatchEvent(e);};ws.onerror=function(event){if(self.debug||ReconnectingWebSocket.debugAll){console.debug(\"ReconnectingWebSocket\",\"onerror\",self.url,event);}eventTarget.dispatchEvent(generateEvent(\"error\"));};};// Whether or not to create a websocket upon instantiation\nif(this.automaticOpen==true){this.open(false);}/**\n     * Transmits data to the server over the WebSocket connection.\n     *\n     * @param data a text string, ArrayBuffer or Blob to send to the server.\n     */this.send=function(data){if(ws){if(self.debug||ReconnectingWebSocket.debugAll){console.debug(\"ReconnectingWebSocket\",\"send\",self.url,data);}return ws.send(data);}else{throw\"INVALID_STATE_ERR : Pausing to reconnect websocket\";}};/**\n     * Closes the WebSocket connection or connection attempt, if any.\n     * If the connection is already CLOSED, this method does nothing.\n     */this.close=function(code,reason){// Default CLOSE_NORMAL code\nif(typeof code==\"undefined\"){code=1000;}forcedClose=true;if(ws){ws.close(code,reason);}};/**\n     * Additional public API method to refresh the connection if still open (close, re-open).\n     * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\n     */this.refresh=function(){if(ws){ws.close();}};}/**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data.\n   */ReconnectingWebSocket.prototype.onopen=function(event){};/** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */ReconnectingWebSocket.prototype.onclose=function(event){};/** An event listener to be called when a connection begins being attempted. */ReconnectingWebSocket.prototype.onconnecting=function(event){};/** An event listener to be called when a message is received from the server. */ReconnectingWebSocket.prototype.onmessage=function(event){};/** An event listener to be called when an error occurs. */ReconnectingWebSocket.prototype.onerror=function(event){};/**\n   * Whether all instances of ReconnectingWebSocket should log debug messages.\n   * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\n   */ReconnectingWebSocket.debugAll=false;ReconnectingWebSocket.CONNECTING=WebSocket.CONNECTING;ReconnectingWebSocket.OPEN=WebSocket.OPEN;ReconnectingWebSocket.CLOSING=WebSocket.CLOSING;ReconnectingWebSocket.CLOSED=WebSocket.CLOSED;return ReconnectingWebSocket;});","map":{"version":3,"sources":["/home/y-yabust/CC/cc-replay/src/io/reconnecting-websocket.js"],"names":["global","factory","define","amd","module","exports","ReconnectingWebSocket","window","url","protocols","options","settings","debug","automaticOpen","reconnectInterval","maxReconnectInterval","reconnectDecay","timeoutInterval","maxReconnectAttempts","binaryType","key","reconnectAttempts","readyState","WebSocket","CONNECTING","protocol","self","ws","forcedClose","timedOut","eventTarget","document","createElement","addEventListener","event","onopen","onclose","onconnecting","onmessage","onerror","bind","removeEventListener","dispatchEvent","generateEvent","s","args","evt","createEvent","initCustomEvent","open","reconnectAttempt","debugAll","console","localWs","timeout","setTimeout","close","clearTimeout","OPEN","e","isReconnect","CLOSED","code","reason","wasClean","Math","pow","data","send","refresh","prototype","CLOSING"],"mappings":"AAAA,oB,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,CAAC,SAASA,MAAT,CAAiBC,OAAjB,CAA0B,CACzB,GAAI,MAAOC,CAAAA,MAAP,GAAkB,UAAlB,EAAgCA,MAAM,CAACC,GAA3C,CAAgD,CAC9CD,MAAM,CAAC,EAAD,CAAKD,OAAL,CAAN,CACD,CAFD,IAEO,IAAI,MAAOG,CAAAA,MAAP,GAAkB,WAAlB,EAAiCA,MAAM,CAACC,OAA5C,CAAqD,CAC1DD,MAAM,CAACC,OAAP,CAAiBJ,OAAO,EAAxB,CACD,CAFM,IAEA,CACLD,MAAM,CAACM,qBAAP,CAA+BL,OAAO,EAAtC,CACD,CACF,CARD,EAQG,IARH,CAQS,UAAW,CAClB,GAAI,EAAE,aAAeM,CAAAA,MAAjB,CAAJ,CAA8B,CAC5B,OACD,CAED,QAASD,CAAAA,qBAAT,CAA+BE,GAA/B,CAAoCC,SAApC,CAA+CC,OAA/C,CAAwD,CACtD;AACA,GAAIC,CAAAA,QAAQ,CAAG,CACb,uDACAC,KAAK,CAAE,KAFM,CAIb,6FACAC,aAAa,CAAE,IALF,CAOb,0EACAC,iBAAiB,CAAE,IARN,CASb,0EACAC,oBAAoB,CAAE,KAVT,CAWb,gHACAC,cAAc,CAAE,GAZH,CAcb,wGACAC,eAAe,CAAE,IAfJ,CAiBb,8EACAC,oBAAoB,CAAE,IAlBT,CAoBb,gFACAC,U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","sourcesContent":["/* eslint-disable */\n\n// MIT License:\n//\n// Copyright (c) 2010-2012, Joe Walnes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * This behaves like a WebSocket in every way, except if it fails to connect,\n * or it gets disconnected, it will repeatedly poll until it successfully connects\n * again.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * The event stream will typically look like:\n *  onconnecting\n *  onopen\n *  onmessage\n *  onmessage\n *  onclose // lost connection\n *  onconnecting\n *  onopen  // sometime later...\n *  onmessage\n *  onmessage\n *  etc...\n *\n * It is API compatible with the standard WebSocket API, apart from the following members:\n *\n * - `bufferedAmount`\n * - `extensions`\n * - `binaryType`\n *\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\n * - Joe Walnes\n *\n * Syntax\n * ======\n * var socket = new ReconnectingWebSocket(url, protocols, options);\n *\n * Parameters\n * ==========\n * url - The url you are connecting to.\n * protocols - Optional string or array of protocols.\n * options - See below\n *\n * Options\n * =======\n * Options can either be passed upon instantiation or set after instantiation:\n *\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\n *\n * or\n *\n * var socket = new ReconnectingWebSocket(url);\n * socket.debug = true;\n * socket.reconnectInterval = 4000;\n *\n * debug\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\n *\n * automaticOpen\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n *\n * reconnectInterval\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\n *\n * maxReconnectInterval\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\n *\n * reconnectDecay\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\n *\n * timeoutInterval\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\n *\n */\n(function(global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = factory();\n  } else {\n    global.ReconnectingWebSocket = factory();\n  }\n})(this, function() {\n  if (!(\"WebSocket\" in window)) {\n    return;\n  }\n\n  function ReconnectingWebSocket(url, protocols, options) {\n    // Default settings\n    var settings = {\n      /** Whether this instance should log debug messages. */\n      debug: false,\n\n      /** Whether or not the websocket should attempt to connect immediately upon instantiation. */\n      automaticOpen: true,\n\n      /** The number of milliseconds to delay before attempting to reconnect. */\n      reconnectInterval: 1000,\n      /** The maximum number of milliseconds to delay a reconnection attempt. */\n      maxReconnectInterval: 30000,\n      /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */\n      reconnectDecay: 1.5,\n\n      /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */\n      timeoutInterval: 2000,\n\n      /** The maximum number of reconnection attempts to make. Unlimited if null. */\n      maxReconnectAttempts: null,\n\n      /** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */\n      binaryType: \"blob\"\n    };\n    if (!options) {\n      options = {};\n    }\n\n    // Overwrite and define settings with options if they exist.\n    for (var key in settings) {\n      if (typeof options[key] !== \"undefined\") {\n        this[key] = options[key];\n      } else {\n        this[key] = settings[key];\n      }\n    }\n\n    // These should be treated as read-only properties\n\n    /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */\n    this.url = url;\n\n    /** The number of attempted reconnects since starting, or the last successful connection. Read only. */\n    this.reconnectAttempts = 0;\n\n    /**\n     * The current state of the connection.\n     * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\n     * Read only.\n     */\n    this.readyState = WebSocket.CONNECTING;\n\n    /**\n     * A string indicating the name of the sub-protocol the server selected; this will be one of\n     * the strings specified in the protocols parameter when creating the WebSocket object.\n     * Read only.\n     */\n    this.protocol = null;\n\n    // Private state variables\n\n    var self = this;\n    var ws;\n    var forcedClose = false;\n    var timedOut = false;\n    var eventTarget = document.createElement(\"div\");\n\n    // Wire up \"on*\" properties as event handlers\n\n    eventTarget.addEventListener(\"open\", function(event) {\n      self.onopen(event);\n    });\n    eventTarget.addEventListener(\"close\", function(event) {\n      self.onclose(event);\n    });\n    eventTarget.addEventListener(\"connecting\", function(event) {\n      self.onconnecting(event);\n    });\n    eventTarget.addEventListener(\"message\", function(event) {\n      self.onmessage(event);\n    });\n    eventTarget.addEventListener(\"error\", function(event) {\n      self.onerror(event);\n    });\n\n    // Expose the API required by EventTarget\n\n    this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n    this.removeEventListener = eventTarget.removeEventListener.bind(\n      eventTarget\n    );\n    this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n    /**\n     * This function generates an event that is compatible with standard\n     * compliant browsers and IE9 - IE11\n     *\n     * This will prevent the error:\n     * Object doesn't support this action\n     *\n     * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\n     * @param s String The name that the event should use\n     * @param args Object an optional object that the event will use\n     */\n    function generateEvent(s, args) {\n      var evt = document.createEvent(\"CustomEvent\");\n      evt.initCustomEvent(s, false, false, args);\n      return evt;\n    }\n\n    this.open = function(reconnectAttempt) {\n      ws = new WebSocket(self.url, protocols || []);\n      ws.binaryType = this.binaryType;\n\n      if (reconnectAttempt) {\n        if (\n          this.maxReconnectAttempts &&\n          this.reconnectAttempts > this.maxReconnectAttempts\n        ) {\n          return;\n        }\n      } else {\n        eventTarget.dispatchEvent(generateEvent(\"connecting\"));\n        this.reconnectAttempts = 0;\n      }\n\n      if (self.debug || ReconnectingWebSocket.debugAll) {\n        console.debug(\"ReconnectingWebSocket\", \"attempt-connect\", self.url);\n      }\n\n      var localWs = ws;\n      var timeout = setTimeout(function() {\n        if (self.debug || ReconnectingWebSocket.debugAll) {\n          console.debug(\n            \"ReconnectingWebSocket\",\n            \"connection-timeout\",\n            self.url\n          );\n        }\n        timedOut = true;\n        localWs.close();\n        timedOut = false;\n      }, self.timeoutInterval);\n\n      ws.onopen = function(event) {\n        clearTimeout(timeout);\n        if (self.debug || ReconnectingWebSocket.debugAll) {\n          console.debug(\"ReconnectingWebSocket\", \"onopen\", self.url);\n        }\n        self.protocol = ws.protocol;\n        self.readyState = WebSocket.OPEN;\n        self.reconnectAttempts = 0;\n        var e = generateEvent(\"open\");\n        e.isReconnect = reconnectAttempt;\n        reconnectAttempt = false;\n        eventTarget.dispatchEvent(e);\n      };\n\n      ws.onclose = function(event) {\n        clearTimeout(timeout);\n        ws = null;\n        if (forcedClose) {\n          self.readyState = WebSocket.CLOSED;\n          eventTarget.dispatchEvent(generateEvent(\"close\"));\n        } else {\n          self.readyState = WebSocket.CONNECTING;\n          var e = generateEvent(\"connecting\");\n          e.code = event.code;\n          e.reason = event.reason;\n          e.wasClean = event.wasClean;\n          eventTarget.dispatchEvent(e);\n          if (!reconnectAttempt && !timedOut) {\n            if (self.debug || ReconnectingWebSocket.debugAll) {\n              console.debug(\"ReconnectingWebSocket\", \"onclose\", self.url);\n            }\n            eventTarget.dispatchEvent(generateEvent(\"close\"));\n          }\n\n          var timeout =\n            self.reconnectInterval *\n            Math.pow(self.reconnectDecay, self.reconnectAttempts);\n          setTimeout(\n            function() {\n              self.reconnectAttempts++;\n              self.open(true);\n            },\n            timeout > self.maxReconnectInterval\n              ? self.maxReconnectInterval\n              : timeout\n          );\n        }\n      };\n      ws.onmessage = function(event) {\n        if (self.debug || ReconnectingWebSocket.debugAll) {\n          console.debug(\n            \"ReconnectingWebSocket\",\n            \"onmessage\",\n            self.url,\n            event.data\n          );\n        }\n        var e = generateEvent(\"message\");\n        e.data = event.data;\n        eventTarget.dispatchEvent(e);\n      };\n      ws.onerror = function(event) {\n        if (self.debug || ReconnectingWebSocket.debugAll) {\n          console.debug(\"ReconnectingWebSocket\", \"onerror\", self.url, event);\n        }\n        eventTarget.dispatchEvent(generateEvent(\"error\"));\n      };\n    };\n\n    // Whether or not to create a websocket upon instantiation\n    if (this.automaticOpen == true) {\n      this.open(false);\n    }\n\n    /**\n     * Transmits data to the server over the WebSocket connection.\n     *\n     * @param data a text string, ArrayBuffer or Blob to send to the server.\n     */\n    this.send = function(data) {\n      if (ws) {\n        if (self.debug || ReconnectingWebSocket.debugAll) {\n          console.debug(\"ReconnectingWebSocket\", \"send\", self.url, data);\n        }\n        return ws.send(data);\n      } else {\n        throw \"INVALID_STATE_ERR : Pausing to reconnect websocket\";\n      }\n    };\n\n    /**\n     * Closes the WebSocket connection or connection attempt, if any.\n     * If the connection is already CLOSED, this method does nothing.\n     */\n    this.close = function(code, reason) {\n      // Default CLOSE_NORMAL code\n      if (typeof code == \"undefined\") {\n        code = 1000;\n      }\n      forcedClose = true;\n      if (ws) {\n        ws.close(code, reason);\n      }\n    };\n\n    /**\n     * Additional public API method to refresh the connection if still open (close, re-open).\n     * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\n     */\n    this.refresh = function() {\n      if (ws) {\n        ws.close();\n      }\n    };\n  }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data.\n   */\n  ReconnectingWebSocket.prototype.onopen = function(event) {};\n  /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */\n  ReconnectingWebSocket.prototype.onclose = function(event) {};\n  /** An event listener to be called when a connection begins being attempted. */\n  ReconnectingWebSocket.prototype.onconnecting = function(event) {};\n  /** An event listener to be called when a message is received from the server. */\n  ReconnectingWebSocket.prototype.onmessage = function(event) {};\n  /** An event listener to be called when an error occurs. */\n  ReconnectingWebSocket.prototype.onerror = function(event) {};\n\n  /**\n   * Whether all instances of ReconnectingWebSocket should log debug messages.\n   * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\n   */\n  ReconnectingWebSocket.debugAll = false;\n\n  ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\n  ReconnectingWebSocket.OPEN = WebSocket.OPEN;\n  ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\n  ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\n\n  return ReconnectingWebSocket;\n});\n"]},"metadata":{},"sourceType":"module"}