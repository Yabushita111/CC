{"ast":null,"code":"import { streamAll } from \"../io/websocket\";\nimport { makeQueryString, httpToWsProtocol, join } from \"./url\";\nimport { loadSvgs, getSvg, svgExists } from \"./inline-svg\";\nconst DEFAULT_SNAKE_HEAD = \"default\";\nconst DEFAULT_SNAKE_TAIL = \"default\";\nconst APP_VERSION = process.env.REACT_APP_VERSION;\n\nasync function get(url, query) {\n  const response = await fetch(url + makeQueryString(query));\n\n  if (response.status === 200) {\n    return Promise.resolve(response.json());\n  } else {\n    return Promise.resolve(response.json()).then(responseJson => {\n      console.error(responseJson.error);\n      return Promise.reject(responseJson.error);\n    });\n  }\n}\n\nexport function delay(millis) {\n  return new Promise(resolve => setTimeout(resolve, millis));\n}\nexport function getReadableCauseOfDeath(death) {\n  // See https://github.com/BattlesnakeOfficial/rules/blob/master/standard.go\n  switch (death.cause) {\n    case \"snake-collision\":\n      return `Ran into ${death.eliminatedBy}'s body`;\n\n    case \"snake-self-collision\":\n      return \"Collided with itself\";\n\n    case \"out-of-health\":\n      return \"Out of health\";\n\n    case \"hazard\":\n      return \"Eliminated by hazard\";\n\n    case \"head-collision\":\n      return `Lost head-to-head with ${death.eliminatedBy}`;\n\n    case \"wall-collision\":\n      return \"Moved out of bounds\";\n\n    case \"squad-eliminated\":\n      return \"Squad was eliminated\";\n\n    default:\n      return death.cause;\n  }\n} // Gets a list of all unique SVG paths required by the snakes.\n\nfunction getAllSvgs(snakes) {\n  const all = snakes.reduce((result, snake) => {\n    return result.concat([snake.HeadType, snake.TailType]);\n  }, []);\n  const unique = new Set(all);\n  return Array.from(unique);\n}\n\nasync function assignHeadAndTailUrls(snakes) {\n  for (const snake of snakes) {\n    // Assign default if missing\n    if (!snake.HeadType) {\n      snake.HeadType = DEFAULT_SNAKE_HEAD;\n    }\n\n    if (!snake.TailType) {\n      snake.TailType = DEFAULT_SNAKE_TAIL;\n    } // Format as actual URL if it's just a name\n\n\n    snake.HeadType = getSnakeHeadSvgUrl(snake.HeadType);\n    snake.TailType = getSnakeTailSvgUrl(snake.TailType);\n\n    if (!(await svgExists(snake.HeadType))) {\n      snake.HeadType = getSnakeHeadSvgUrl(DEFAULT_SNAKE_HEAD);\n    }\n\n    if (!(await svgExists(snake.TailType))) {\n      snake.TailType = getSnakeTailSvgUrl(DEFAULT_SNAKE_TAIL);\n    }\n  }\n}\n\nasync function setHeadAndTailSvgs(snakes) {\n  await assignHeadAndTailUrls(snakes);\n  await loadSvgs(getAllSvgs(snakes));\n\n  for (const snake of snakes) {\n    snake.HeadSvg = getSvg(snake.HeadType);\n    snake.TailSvg = getSvg(snake.TailType);\n  }\n}\n\nfunction isIllegalSvgPath(nameOrPath) {\n  return nameOrPath.indexOf(\"/\") >= 0 || nameOrPath.indexOf(\".\") >= 0;\n}\n\nfunction svgUrlFromName(base, relative) {\n  //appending the git hash of this version allows for cache busting on deploy\n  const extension = \".svg?board_version=\" + APP_VERSION;\n  return join(\"https://media.battlesnake.com\", base, relative) + extension;\n}\n\nfunction getSnakeHeadSvgUrl(path) {\n  const effectivePath = isIllegalSvgPath(path) ? DEFAULT_SNAKE_HEAD : path;\n  return svgUrlFromName(\"/snakes/heads\", effectivePath);\n}\n\nfunction getSnakeTailSvgUrl(path) {\n  const effectivePath = isIllegalSvgPath(path) ? DEFAULT_SNAKE_TAIL : path;\n  return svgUrlFromName(\"/snakes/tails\", effectivePath);\n}\n\nasync function prepareFrame(frame) {\n  await setHeadAndTailSvgs(frame.Snakes);\n}\n\nexport function fetchGameInfo(baseUrl, gameId) {\n  const url = join(baseUrl, `games/${gameId}`);\n  return get(url);\n}\nexport async function streamAllEvents(baseUrl, gameId, receiveEvent) {\n  const game = await fetchGameInfo(baseUrl, gameId);\n  let chain = Promise.resolve();\n\n  function onEngineEvent(engineEvent) {\n    if (engineEvent.Type) {\n      const eventData = engineEvent.Data || engineEvent;\n      chain = chain.then(async () => {\n        if (engineEvent.Type === \"frame\") {\n          await prepareFrame(eventData);\n        }\n\n        console.log(receiveEvent(game, engineEvent.Type, eventData));\n        return receiveEvent(game, engineEvent.Type, eventData);\n      });\n    }\n\n    return engineEvent.Type && engineEvent.Type === \"game_end\";\n  }\n\n  const wsUrl = join(httpToWsProtocol(baseUrl), `games/${gameId}/events`);\n  console.log(streamAll(wsUrl, onEngineEvent));\n  await streamAll(wsUrl, onEngineEvent);\n  await chain;\n}\nexport function getFrameByTurn(frames, turn) {\n  return frames.filter(frame => frame.turn === turn)[0];\n}","map":{"version":3,"sources":["/Users/yabu/board/src/utils/engine-client.js"],"names":["streamAll","makeQueryString","httpToWsProtocol","join","loadSvgs","getSvg","svgExists","DEFAULT_SNAKE_HEAD","DEFAULT_SNAKE_TAIL","APP_VERSION","process","env","REACT_APP_VERSION","get","url","query","response","fetch","status","Promise","resolve","json","then","responseJson","console","error","reject","delay","millis","setTimeout","getReadableCauseOfDeath","death","cause","eliminatedBy","getAllSvgs","snakes","all","reduce","result","snake","concat","HeadType","TailType","unique","Set","Array","from","assignHeadAndTailUrls","getSnakeHeadSvgUrl","getSnakeTailSvgUrl","setHeadAndTailSvgs","HeadSvg","TailSvg","isIllegalSvgPath","nameOrPath","indexOf","svgUrlFromName","base","relative","extension","path","effectivePath","prepareFrame","frame","Snakes","fetchGameInfo","baseUrl","gameId","streamAllEvents","receiveEvent","game","chain","onEngineEvent","engineEvent","Type","eventData","Data","log","wsUrl","getFrameByTurn","frames","turn","filter"],"mappings":"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","sourcesContent":["import { streamAll } from \"../io/websocket\";\nimport { makeQueryString, httpToWsProtocol, join } from \"./url\";\nimport { loadSvgs, getSvg, svgExists } from \"./inline-svg\";\n\nconst DEFAULT_SNAKE_HEAD = \"default\";\nconst DEFAULT_SNAKE_TAIL = \"default\";\nconst APP_VERSION = process.env.REACT_APP_VERSION;\n\nasync function get(url, query) {\n  const response = await fetch(url + makeQueryString(query));\n  if (response.status === 200) {\n    return Promise.resolve(response.json());\n  } else {\n    return Promise.resolve(response.json()).then(responseJson => {\n      console.error(responseJson.error);\n      return Promise.reject(responseJson.error);\n    });\n  }\n}\n\nexport function delay(millis) {\n  return new Promise(resolve => setTimeout(resolve, millis));\n}\n\nexport function getReadableCauseOfDeath(death) {\n  // See https://github.com/BattlesnakeOfficial/rules/blob/master/standard.go\n  switch (death.cause) {\n    case \"snake-collision\":\n      return `Ran into ${death.eliminatedBy}'s body`;\n    case \"snake-self-collision\":\n      return \"Collided with itself\";\n    case \"out-of-health\":\n      return \"Out of health\";\n    case \"hazard\":\n      return \"Eliminated by hazard\";\n    case \"head-collision\":\n      return `Lost head-to-head with ${death.eliminatedBy}`;\n    case \"wall-collision\":\n      return \"Moved out of bounds\";\n    case \"squad-eliminated\":\n      return \"Squad was eliminated\";\n    default:\n      return death.cause;\n  }\n}\n\n// Gets a list of all unique SVG paths required by the snakes.\nfunction getAllSvgs(snakes) {\n  const all = snakes.reduce((result, snake) => {\n    return result.concat([snake.HeadType, snake.TailType]);\n  }, []);\n  const unique = new Set(all);\n  return Array.from(unique);\n}\n\nasync function assignHeadAndTailUrls(snakes) {\n  for (const snake of snakes) {\n    // Assign default if missing\n    if (!snake.HeadType) {\n      snake.HeadType = DEFAULT_SNAKE_HEAD;\n    }\n    if (!snake.TailType) {\n      snake.TailType = DEFAULT_SNAKE_TAIL;\n    }\n\n    // Format as actual URL if it's just a name\n    snake.HeadType = getSnakeHeadSvgUrl(snake.HeadType);\n    snake.TailType = getSnakeTailSvgUrl(snake.TailType);\n\n    if (!(await svgExists(snake.HeadType))) {\n      snake.HeadType = getSnakeHeadSvgUrl(DEFAULT_SNAKE_HEAD);\n    }\n    if (!(await svgExists(snake.TailType))) {\n      snake.TailType = getSnakeTailSvgUrl(DEFAULT_SNAKE_TAIL);\n    }\n  }\n}\n\nasync function setHeadAndTailSvgs(snakes) {\n  await assignHeadAndTailUrls(snakes);\n  await loadSvgs(getAllSvgs(snakes));\n\n  for (const snake of snakes) {\n    snake.HeadSvg = getSvg(snake.HeadType);\n    snake.TailSvg = getSvg(snake.TailType);\n  }\n}\n\nfunction isIllegalSvgPath(nameOrPath) {\n  return nameOrPath.indexOf(\"/\") >= 0 || nameOrPath.indexOf(\".\") >= 0;\n}\n\nfunction svgUrlFromName(base, relative) {\n  //appending the git hash of this version allows for cache busting on deploy\n  const extension = \".svg?board_version=\" + APP_VERSION;\n  return join(\"https://media.battlesnake.com\", base, relative) + extension;\n}\n\nfunction getSnakeHeadSvgUrl(path) {\n  const effectivePath = isIllegalSvgPath(path) ? DEFAULT_SNAKE_HEAD : path;\n  return svgUrlFromName(\"/snakes/heads\", effectivePath);\n}\n\nfunction getSnakeTailSvgUrl(path) {\n  const effectivePath = isIllegalSvgPath(path) ? DEFAULT_SNAKE_TAIL : path;\n  return svgUrlFromName(\"/snakes/tails\", effectivePath);\n}\n\nasync function prepareFrame(frame) {\n  await setHeadAndTailSvgs(frame.Snakes);\n}\n\nexport function fetchGameInfo(baseUrl, gameId) {\n  const url = join(baseUrl, `games/${gameId}`);\n  return get(url);\n}\n\nexport async function streamAllEvents(baseUrl, gameId, receiveEvent) {\n  const game = await fetchGameInfo(baseUrl, gameId);\n\n  let chain = Promise.resolve();\n  function onEngineEvent(engineEvent) {\n    if (engineEvent.Type) {\n      const eventData = engineEvent.Data || engineEvent;\n\n      chain = chain.then(async () => {\n        if (engineEvent.Type === \"frame\") {\n          await prepareFrame(eventData);\n        }\n        console.log(receiveEvent(game, engineEvent.Type, eventData));\n        return receiveEvent(game, engineEvent.Type, eventData);\n      });\n    }\n    return engineEvent.Type && engineEvent.Type === \"game_end\";\n  }\n\n  const wsUrl = join(httpToWsProtocol(baseUrl), `games/${gameId}/events`);\n  console.log(streamAll(wsUrl, onEngineEvent));\n  await streamAll(wsUrl, onEngineEvent);\n  await chain;\n}\n\nexport function getFrameByTurn(frames, turn) {\n  return frames.filter(frame => frame.turn === turn)[0];\n}\n"]},"metadata":{},"sourceType":"module"}