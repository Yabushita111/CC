{"ast":null,"code":"// Creates a dictionary of parameters based on the given query string. q should\n// look like \"?foo=bar&thing=blah\".\nexport function parseQueryString(q){if(!q||!q.length){return{};}// Array of key/value pairs\nvar args=q.substr(1).split(\"&\").map(parseArg);//?game_idでアクセス可能\nvar href=window.location.href;args[\"engine\"]=href.substr(0,href.lastIndexOf(\"/\")+1);// Convert to object\nreturn args.reduce(function(result,arg){result[arg.key]=arg.value;return result;},{});}// Converts “asdf=qwer” to { asdf: “qwer” } or “asdf” to { asdf: true }. The\n// latter example is to allow switch-like parameters like ?enableThing without\n// an equals sign.\nfunction parseArg(a){var parts=a.split(\"=\");var key=parts[0];var value=parts[1]===undefined?true:decodeURIComponent(parts[1]);return{key:key,value:value};}// Converts { a: \"aaa\", b: \"bbb\" } to \"?a=aaa&b=bbb\"\nexport function makeQueryString(query){if(!query){return\"\";}var sep=\"?\";var result=\"\";for(var key in query){var value=query[key];result+=\"\".concat(sep).concat(key,\"=\").concat(value);sep=\"&\";}return result;}// Converts http://foo to ws://foo or https://foo to wss://foo\nexport function httpToWsProtocol(url){var mappings={http:\"ws\",https:\"wss\"};for(var from in mappings){var to=mappings[from];if(url.substr(0,from.length+1)===from+\":\"){return to+url.substr(from.length);}}throw new Error(\"Invalid URL: \"+url);}// Joins path components and makes sure there is exactly one '/' separating\n// them.\nexport function join(){function joinPair(a,b){var cleanA=a.replace(/\\/+$/,\"\");var cleanB=b.replace(/^\\/+/,\"\");if(cleanA===\"\"){return cleanB;}if(cleanB===\"\"){return cleanA;}return\"\".concat(cleanA,\"/\").concat(cleanB);}for(var _len=arguments.length,parts=new Array(_len),_key=0;_key<_len;_key++){parts[_key]=arguments[_key];}return parts.reduce(function(current,next){return joinPair(current,next);},\"\");}","map":{"version":3,"sources":["/home/y-yabust/CC/cc-replay/src/utils/url.js"],"names":["parseQueryString","q","length","args","substr","split","map","parseArg","href","window","location","lastIndexOf","reduce","result","arg","key","value","a","parts","undefined","decodeURIComponent","makeQueryString","query","sep","httpToWsProtocol","url","mappings","http","https","from","to","Error","join","joinPair","b","cleanA","replace","cleanB","current","next"],"mappings":"AAAA;AACA;AACA,MAAO,SAASA,CAAAA,gBAAT,CAA0BC,CAA1B,CAA6B,CAClC,GAAI,CAACA,CAAD,EAAM,CAACA,CAAC,CAACC,MAAb,CAAqB,CACnB,MAAO,EAAP,CACD,CAED;AACA,GAAMC,CAAAA,IAAI,CAAGF,CAAC,CACXG,MADU,CACH,CADG,EAEVC,KAFU,CAEJ,GAFI,EAGVC,GAHU,CAGNC,QAHM,CAAb,CAKA;AACA,GAAMC,CAAAA,IAAI,CAAGC,MAAM,CAACC,QAAP,CAAgBF,IAA7B,CACAL,IAAI,CAAC,QAAD,CAAJ,CAAiBK,IAAI,CAACJ,MAAL,CAAY,CAAZ,CAAeI,IAAI,CAACG,WAAL,CAAiB,GAAjB,EAAwB,CAAvC,CAAjB,CAEA;AACA,MAAOR,CAAAA,IAAI,CAACS,MAAL,CAAY,SAACC,MAAD,CAASC,GAAT,CAAiB,CAClCD,MAAM,CAACC,GAAG,CAACC,GAAL,CAAN,CAAkBD,GAAG,CAACE,KAAtB,CACA,MAAOH,CAAAA,MAAP,CACD,CAHM,CAGJ,EAHI,CAAP,CAID,CACD;AACA;AACA;AACA,QAASN,CAAAA,QAAT,CAAkBU,CAAlB,CAAqB,CACnB,GAAMC,CAAAA,KAAK,CAAGD,CAAC,CAACZ,KAAF,CAAQ,GAAR,CAAd,CACA,GAAMU,CAAAA,GAAG,CAAGG,KAAK,CAAC,CAAD,CAAjB,CACA,GAAMF,CAAAA,KAAK,CAAGE,KAAK,CAAC,CAAD,CAAL,GAAaC,SAAb,CAAyB,IAAzB,CAAgCC,kBAAkB,CAACF,KAAK,CAAC,CAAD,CAAN,CAAhE,CACA,MAAO,CAAEH,GAAG,CAAHA,GAAF,CAAOC,KAAK,CAALA,KAAP,CAAP,CACD,CAED;AACA,MAAO,SAASK,CAAAA,eAAT,CAAyBC,KAAzB,CAAgC,CACrC,GAAI,CAACA,KAAL,CAAY,CACV,MAAO,EAAP,CACD,CAED,GAAIC,CAAAA,GAAG,CAAG,GAAV,CACA,GAAIV,CAAAA,MAAM,CAAG,EAAb,CAEA,IAAK,GAAME,CAAAA,GAAX,GAAkBO,CAAAA,KAAlB,CAAyB,CACvB,GAAMN,CAAAA,KAAK,CAAGM,KAAK,CAACP,GAAD,CAAnB,CACAF,MAAM,YAAOU,GAAP,SAAaR,GAAb,aAAoBC,KAApB,CAAN,CACAO,GAAG,CAAG,GAAN,CACD,CACD,MAAOV,CAAAA,MAAP,CACD,CAED;AACA,MAAO,SAASW,CAAAA,gBAAT,CAA0BC,GAA1B,CAA+B,CACpC,GAAMC,CAAAA,QAAQ,CAAG,CACfC,IAAI,CAAE,IADS,CAEfC,KAAK,CAAE,KAFQ,CAAjB,CAKA,IAAK,GAAMC,CAAAA,IAAX,GAAmBH,CAAAA,QAAnB,CAA6B,CAC3B,GAAMI,CAAAA,EAAE,CAAGJ,QAAQ,CAACG,IAAD,CAAnB,CACA,GAAIJ,GAAG,CAACrB,MAAJ,CAAW,CAAX,CAAcyB,IAAI,CAAC3B,MAAL,CAAc,CAA5B,IAAmC2B,IAAI,CAAG,GAA9C,CAAmD,CACjD,MAAOC,CAAAA,EAAE,CAAGL,GAAG,CAACrB,MAAJ,CAAWyB,IAAI,CAAC3B,MAAhB,CAAZ,CACD,CACF,CAED,KAAM,IAAI6B,CAAAA,KAAJ,CAAU,gBAAkBN,GAA5B,CAAN,CACD,CAED;AACA;AACA,MAAO,SAASO,CAAAA,IAAT,EAAwB,CAC7B,QAASC,CAAAA,QAAT,CAAkBhB,CAAlB,CAAqBiB,CAArB,CAAwB,CACtB,GAAMC,CAAAA,MAAM,CAAGlB,CAAC,CAACmB,OAAF,CAAU,MAAV,CAAkB,EAAlB,CAAf,CACA,GAAMC,CAAAA,MAAM,CAAGH,CAAC,CAACE,OAAF,CAAU,MAAV,CAAkB,EAAlB,CAAf,CAEA,GAAID,MAAM,GAAK,EAAf,CAAmB,CACjB,MAAOE,CAAAA,MAAP,CACD,CAED,GAAIA,MAAM,GAAK,EAAf,CAAmB,CACjB,MAAOF,CAAAA,MAAP,CACD,CAED,gBAAUA,MAAV,aAAoBE,MAApB,EACD,CAd4B,8BAAPnB,KAAO,0CAAPA,KAAO,wBAgB7B,MAAOA,CAAAA,KAAK,CAACN,MAAN,CAAa,SAAC0B,OAAD,CAAUC,IAAV,QAAmBN,CAAAA,QAAQ,CAACK,OAAD,CAAUC,IAAV,CAA3B,EAAb,CAAyD,EAAzD,CAAP,CACD","sourcesContent":["// Creates a dictionary of parameters based on the given query string. q should\n// look like \"?foo=bar&thing=blah\".\nexport function parseQueryString(q) {\n  if (!q || !q.length) {\n    return {};\n  }\n\n  // Array of key/value pairs\n  const args = q\n    .substr(1)\n    .split(\"&\")\n    .map(parseArg);\n\n  //?game_idでアクセス可能\n  const href = window.location.href;\n  args[\"engine\"] = href.substr(0, href.lastIndexOf(\"/\") + 1);\n\n  // Convert to object\n  return args.reduce((result, arg) => {\n    result[arg.key] = arg.value;\n    return result;\n  }, {});\n}\n// Converts “asdf=qwer” to { asdf: “qwer” } or “asdf” to { asdf: true }. The\n// latter example is to allow switch-like parameters like ?enableThing without\n// an equals sign.\nfunction parseArg(a) {\n  const parts = a.split(\"=\");\n  const key = parts[0];\n  const value = parts[1] === undefined ? true : decodeURIComponent(parts[1]);\n  return { key, value };\n}\n\n// Converts { a: \"aaa\", b: \"bbb\" } to \"?a=aaa&b=bbb\"\nexport function makeQueryString(query) {\n  if (!query) {\n    return \"\";\n  }\n\n  let sep = \"?\";\n  let result = \"\";\n\n  for (const key in query) {\n    const value = query[key];\n    result += `${sep}${key}=${value}`;\n    sep = \"&\";\n  }\n  return result;\n}\n\n// Converts http://foo to ws://foo or https://foo to wss://foo\nexport function httpToWsProtocol(url) {\n  const mappings = {\n    http: \"ws\",\n    https: \"wss\"\n  };\n\n  for (const from in mappings) {\n    const to = mappings[from];\n    if (url.substr(0, from.length + 1) === from + \":\") {\n      return to + url.substr(from.length);\n    }\n  }\n\n  throw new Error(\"Invalid URL: \" + url);\n}\n\n// Joins path components and makes sure there is exactly one '/' separating\n// them.\nexport function join(...parts) {\n  function joinPair(a, b) {\n    const cleanA = a.replace(/\\/+$/, \"\");\n    const cleanB = b.replace(/^\\/+/, \"\");\n\n    if (cleanA === \"\") {\n      return cleanB;\n    }\n\n    if (cleanB === \"\") {\n      return cleanA;\n    }\n\n    return `${cleanA}/${cleanB}`;\n  }\n\n  return parts.reduce((current, next) => joinPair(current, next), \"\");\n}\n"]},"metadata":{},"sourceType":"module"}