{"ast":null,"code":"import { delay, getFrameByTurn, streamAllEvents } from \"../utils/engine-client\";\nimport * as types from \"./action-types\";\nimport { DEFAULT_FRAMERATE } from \"../components/settings/defaults\";\nexport const setGameOptions = gameOptions => ({\n  type: types.SET_GAME_OPTIONS,\n  gameOptions\n});\nexport const setTheme = theme => ({\n  type: types.SET_THEME,\n  theme\n});\nexport const gameOver = () => ({\n  type: types.GAME_OVER\n});\nexport const gameNotFound = () => ({\n  type: types.GAME_NOT_FOUND\n});\nexport const requestFrames = () => ({\n  type: types.REQUEST_FRAMES\n});\nexport const receiveFrame = (game, frame) => ({\n  type: types.RECEIVE_FRAME,\n  game,\n  frame\n});\nexport const receiveEventEnd = (game, endEvent, frame) => ({\n  type: types.RECEIVE_EVENT_END,\n  game,\n  endEvent,\n  frame\n});\nexport const setCurrentFrame = frame => ({\n  type: types.SET_CURRENT_FRAME,\n  frame\n});\nexport const pauseGame = () => ({\n  type: types.PAUSE_GAME\n});\nexport const resumeGame = () => ({\n  type: types.RESUME_GAME\n});\nexport const highlightSnake = snakeId => ({\n  type: types.HIGHLIGHT_SNAKE,\n  snakeId\n});\nexport const fetchFrames = () => {\n  return async (dispatch, getState) => {\n    const {\n      autoplay,\n      engine: engineUrl,\n      game: gameId,\n      turn\n    } = getState().game.gameOptions;\n    dispatch(requestFrames());\n\n    try {\n      await streamAllEvents(engineUrl, gameId, (game, eventType, eventData) => {\n        if (eventType === \"frame\") {\n          const frame = eventData; // Workaround for bug where turn exluded on turn 0\n\n          frame.Turn = frame.Turn || 0;\n          dispatch(receiveFrame(game, frame)); // Workaround to render the first frame into the board\n\n          if (frame.Turn === 0) {\n            const frame = getState().game.frames[0];\n            dispatch(setCurrentFrame(frame));\n\n            if (autoplay) {\n              dispatch(resumeGame());\n              dispatch(playFromFrame(frame));\n            }\n          }\n        } else if (eventType === \"game_end\") {\n          const numFrames = getState().game.frames.length;\n          const frame = getState().game.frames[numFrames - 1];\n          frame.gameOver = true;\n          dispatch(receiveEventEnd(game, eventData, frame));\n        }\n      });\n    } catch (e) {\n      return dispatch(gameNotFound());\n    } // Only navigate to the specified frame if it is within the\n    // amount of frames available in the game\n\n\n    if (turn && turn <= getState().game.frames.length) {\n      const frame = getState().game.frames[turn];\n      dispatch(setCurrentFrame(frame));\n    }\n  };\n};\nexport const playFromFrame = frame => {\n  return async (dispatch, getState) => {\n    const {\n      frameRate\n    } = getState().game.gameOptions;\n    const frames = getState().game.frames.slice(); // Don't modify in place\n\n    const frameIndex = frames.indexOf(frame);\n    const slicedFrames = frames.slice(frameIndex);\n    const ceiledFps = Math.ceil(frameRate || DEFAULT_FRAMERATE);\n    const delayMillis = 1000 / ceiledFps;\n\n    for (const frame of slicedFrames) {\n      if (getState().game.paused) return;\n      dispatch(setCurrentFrame(frame));\n      await delay(delayMillis);\n    }\n\n    const lastFrame = slicedFrames[slicedFrames.length - 1];\n\n    if (lastFrame.gameOver) {\n      if (!getState().game.paused) {\n        if (getState().game.gameOptions.loop) {\n          const frame = getFrameByTurn(frames, 0);\n          dispatch(playFromFrame(frame));\n        } else {\n          dispatch(gameOver());\n        }\n      }\n    } else {\n      dispatch(playFromFrame(lastFrame));\n    }\n  };\n};\nexport const reloadGame = () => {\n  return async (dispatch, getState) => {\n    const {\n      frames,\n      paused\n    } = getState().game;\n\n    if (paused) {\n      const frame = getFrameByTurn(frames, 0);\n      dispatch(setCurrentFrame(frame));\n    }\n  };\n};\nexport const toggleGamePause = () => {\n  return async (dispatch, getState) => {\n    const {\n      currentFrame,\n      paused\n    } = getState().game;\n\n    if (paused) {\n      dispatch(resumeGame());\n      dispatch(playFromFrame(currentFrame));\n    } else {\n      dispatch(pauseGame());\n    }\n  };\n};\nexport const pauseGameAction = () => {\n  return async (dispatch, getState) => {\n    const {\n      paused\n    } = getState().game;\n\n    if (!paused) {\n      dispatch(pauseGame());\n    }\n  };\n};\nexport const toggleTheme = themeToSet => {\n  return async dispatch => {\n    dispatch(setTheme(themeToSet));\n  };\n};\nexport const stepForwardFrame = () => {\n  return async (dispatch, getState) => {\n    const {\n      currentFrame,\n      frames\n    } = getState().game;\n    const nextFrame = currentFrame.turn + 1;\n    const stepToFrame = getFrameByTurn(frames, nextFrame);\n\n    if (stepToFrame) {\n      dispatch(setCurrentFrame(stepToFrame));\n    }\n  };\n};\nexport const stepBackwardFrame = () => {\n  return async (dispatch, getState) => {\n    const {\n      currentFrame,\n      frames\n    } = getState().game;\n    const prevFrame = currentFrame.turn - 1;\n    const stepToFrame = getFrameByTurn(frames, prevFrame);\n\n    if (stepToFrame) {\n      dispatch(setCurrentFrame(stepToFrame));\n    }\n  };\n};\nexport const stepToTurn = turn => {\n  return async (dispatch, getState) => {\n    const {\n      frames\n    } = getState().game;\n    const stepToFrame = getFrameByTurn(frames, turn);\n\n    if (stepToFrame) {\n      dispatch(setCurrentFrame(stepToFrame));\n    }\n  };\n};\nexport const togglePlayButtons = showHide => ({\n  type: types.TOGGLE_SETTINGS_VIEW,\n  showHide\n});\nexport const themeChanged = theme => ({\n  type: types.THEME_CHANGED,\n  theme\n});","map":{"version":3,"sources":["/home/yabust/CC/board/src/actions/index.js"],"names":["delay","getFrameByTurn","streamAllEvents","types","DEFAULT_FRAMERATE","setGameOptions","gameOptions","type","SET_GAME_OPTIONS","setTheme","theme","SET_THEME","gameOver","GAME_OVER","gameNotFound","GAME_NOT_FOUND","requestFrames","REQUEST_FRAMES","receiveFrame","game","frame","RECEIVE_FRAME","receiveEventEnd","endEvent","RECEIVE_EVENT_END","setCurrentFrame","SET_CURRENT_FRAME","pauseGame","PAUSE_GAME","resumeGame","RESUME_GAME","highlightSnake","snakeId","HIGHLIGHT_SNAKE","fetchFrames","dispatch","getState","autoplay","engine","engineUrl","gameId","turn","eventType","eventData","Turn","frames","playFromFrame","numFrames","length","e","frameRate","slice","frameIndex","indexOf","slicedFrames","ceiledFps","Math","ceil","delayMillis","paused","lastFrame","loop","reloadGame","toggleGamePause","currentFrame","pauseGameAction","toggleTheme","themeToSet","stepForwardFrame","nextFrame","stepToFrame","stepBackwardFrame","prevFrame","stepToTurn","togglePlayButtons","showHide","TOGGLE_SETTINGS_VIEW","themeChanged","THEME_CHANGED"],"mappings":"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","sourcesContent":["import { delay, getFrameByTurn, streamAllEvents } from \"../utils/engine-client\";\nimport * as types from \"./action-types\";\nimport { DEFAULT_FRAMERATE } from \"../components/settings/defaults\";\n\nexport const setGameOptions = gameOptions => ({\n  type: types.SET_GAME_OPTIONS,\n  gameOptions\n});\n\nexport const setTheme = theme => ({\n  type: types.SET_THEME,\n  theme\n});\n\nexport const gameOver = () => ({\n  type: types.GAME_OVER\n});\n\nexport const gameNotFound = () => ({\n  type: types.GAME_NOT_FOUND\n});\n\nexport const requestFrames = () => ({\n  type: types.REQUEST_FRAMES\n});\n\nexport const receiveFrame = (game, frame) => ({\n  type: types.RECEIVE_FRAME,\n  game,\n  frame\n});\n\nexport const receiveEventEnd = (game, endEvent, frame) => ({\n  type: types.RECEIVE_EVENT_END,\n  game,\n  endEvent,\n  frame\n});\n\nexport const setCurrentFrame = frame => ({\n  type: types.SET_CURRENT_FRAME,\n  frame\n});\n\nexport const pauseGame = () => ({\n  type: types.PAUSE_GAME\n});\n\nexport const resumeGame = () => ({\n  type: types.RESUME_GAME\n});\n\nexport const highlightSnake = snakeId => ({\n  type: types.HIGHLIGHT_SNAKE,\n  snakeId\n});\n\nexport const fetchFrames = () => {\n  return async (dispatch, getState) => {\n    const {\n      autoplay,\n      engine: engineUrl,\n      game: gameId,\n      turn\n    } = getState().game.gameOptions;\n\n    dispatch(requestFrames());\n\n    try {\n      await streamAllEvents(engineUrl, gameId, (game, eventType, eventData) => {\n        if (eventType === \"frame\") {\n          const frame = eventData;\n          // Workaround for bug where turn exluded on turn 0\n          frame.Turn = frame.Turn || 0;\n          dispatch(receiveFrame(game, frame));\n\n          // Workaround to render the first frame into the board\n          if (frame.Turn === 0) {\n            const frame = getState().game.frames[0];\n            dispatch(setCurrentFrame(frame));\n\n            if (autoplay) {\n              dispatch(resumeGame());\n              dispatch(playFromFrame(frame));\n            }\n          }\n        } else if (eventType === \"game_end\") {\n          const numFrames = getState().game.frames.length;\n          const frame = getState().game.frames[numFrames - 1];\n          frame.gameOver = true;\n          dispatch(receiveEventEnd(game, eventData, frame));\n        }\n      });\n    } catch (e) {\n      return dispatch(gameNotFound());\n    }\n\n    // Only navigate to the specified frame if it is within the\n    // amount of frames available in the game\n    if (turn && turn <= getState().game.frames.length) {\n      const frame = getState().game.frames[turn];\n      dispatch(setCurrentFrame(frame));\n    }\n  };\n};\n\nexport const playFromFrame = frame => {\n  return async (dispatch, getState) => {\n    const { frameRate } = getState().game.gameOptions;\n    const frames = getState().game.frames.slice(); // Don't modify in place\n    const frameIndex = frames.indexOf(frame);\n    const slicedFrames = frames.slice(frameIndex);\n\n    const ceiledFps = Math.ceil(frameRate || DEFAULT_FRAMERATE);\n    const delayMillis = 1000 / ceiledFps;\n\n    for (const frame of slicedFrames) {\n      if (getState().game.paused) return;\n      dispatch(setCurrentFrame(frame));\n      await delay(delayMillis);\n    }\n\n    const lastFrame = slicedFrames[slicedFrames.length - 1];\n    if (lastFrame.gameOver) {\n      if (!getState().game.paused) {\n        if (getState().game.gameOptions.loop) {\n          const frame = getFrameByTurn(frames, 0);\n          dispatch(playFromFrame(frame));\n        } else {\n          dispatch(gameOver());\n        }\n      }\n    } else {\n      dispatch(playFromFrame(lastFrame));\n    }\n  };\n};\n\nexport const reloadGame = () => {\n  return async (dispatch, getState) => {\n    const { frames, paused } = getState().game;\n    if (paused) {\n      const frame = getFrameByTurn(frames, 0);\n      dispatch(setCurrentFrame(frame));\n    }\n  };\n};\n\nexport const toggleGamePause = () => {\n  return async (dispatch, getState) => {\n    const { currentFrame, paused } = getState().game;\n\n    if (paused) {\n      dispatch(resumeGame());\n      dispatch(playFromFrame(currentFrame));\n    } else {\n      dispatch(pauseGame());\n    }\n  };\n};\n\nexport const pauseGameAction = () => {\n  return async (dispatch, getState) => {\n    const { paused } = getState().game;\n\n    if (!paused) {\n      dispatch(pauseGame());\n    }\n  };\n};\n\nexport const toggleTheme = themeToSet => {\n  return async dispatch => {\n    dispatch(setTheme(themeToSet));\n  };\n};\n\nexport const stepForwardFrame = () => {\n  return async (dispatch, getState) => {\n    const { currentFrame, frames } = getState().game;\n    const nextFrame = currentFrame.turn + 1;\n    const stepToFrame = getFrameByTurn(frames, nextFrame);\n    if (stepToFrame) {\n      dispatch(setCurrentFrame(stepToFrame));\n    }\n  };\n};\n\nexport const stepBackwardFrame = () => {\n  return async (dispatch, getState) => {\n    const { currentFrame, frames } = getState().game;\n    const prevFrame = currentFrame.turn - 1;\n    const stepToFrame = getFrameByTurn(frames, prevFrame);\n    if (stepToFrame) {\n      dispatch(setCurrentFrame(stepToFrame));\n    }\n  };\n};\n\nexport const stepToTurn = turn => {\n  return async (dispatch, getState) => {\n    const { frames } = getState().game;\n\n    const stepToFrame = getFrameByTurn(frames, turn);\n    if (stepToFrame) {\n      dispatch(setCurrentFrame(stepToFrame));\n    }\n  };\n};\n\nexport const togglePlayButtons = showHide => ({\n  type: types.TOGGLE_SETTINGS_VIEW,\n  showHide\n});\n\nexport const themeChanged = theme => ({\n  type: types.THEME_CHANGED,\n  theme\n});\n"]},"metadata":{},"sourceType":"module"}