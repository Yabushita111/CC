{"ast":null,"code":"// Creates a dictionary of parameters based on the given query string. q should\n// look like \"?foo=bar&thing=blah\".\nexport function parseQueryString(q) {\n  if (!q || !q.length) {\n    return {};\n  } // Array of key/value pairs\n\n\n  const args = q.substr(1).split(\"&\").map(parseArg); // Convert to object\n\n  return args.reduce((result, arg) => {\n    result[arg.key] = arg.value;\n    return result;\n  }, {});\n} // Converts \"asdf=qwer\" to { asdf: \"qwer\" } or \"asdf\" to { asdf: true }. The\n// latter example is to allow switch-like parameters like ?enableThing without\n// an equals sign.\n\nfunction parseArg(a) {\n  const parts = a.split(\"=\");\n  const key = parts[0];\n  const value = parts[1] === undefined ? true : decodeURIComponent(parts[1]);\n  return {\n    key,\n    value\n  };\n} // Converts { a: \"aaa\", b: \"bbb\" } to \"?a=aaa&b=bbb\"\n\n\nexport function makeQueryString(query) {\n  if (!query) {\n    return \"\";\n  }\n\n  let sep = \"?\";\n  let result = \"\";\n\n  for (const key in query) {\n    const value = query[key];\n    result += `${sep}${key}=${value}`;\n    sep = \"&\";\n  }\n\n  return result;\n} // Converts http://foo to ws://foo or https://foo to wss://foo\n\nexport function httpToWsProtocol(url) {\n  const mappings = {\n    http: \"ws\",\n    https: \"wss\"\n  };\n\n  for (const from in mappings) {\n    const to = mappings[from];\n\n    if (url.substr(0, from.length + 1) === from + \":\") {\n      return to + url.substr(from.length);\n    }\n  }\n\n  throw new Error(\"Invalid URL: \" + url);\n} // Joins path components and makes sure there is exactly one '/' separating\n// them.\n\nexport function join(...parts) {\n  function joinPair(a, b) {\n    const cleanA = a.replace(/\\/+$/, \"\");\n    const cleanB = b.replace(/^\\/+/, \"\");\n\n    if (cleanA === \"\") {\n      return cleanB;\n    }\n\n    if (cleanB === \"\") {\n      return cleanA;\n    }\n\n    return `${cleanA}/${cleanB}`;\n  }\n\n  return parts.reduce((current, next) => joinPair(current, next), \"\");\n}","map":{"version":3,"sources":["/home/yabust/CC/board/src/utils/url.js"],"names":["parseQueryString","q","length","args","substr","split","map","parseArg","reduce","result","arg","key","value","a","parts","undefined","decodeURIComponent","makeQueryString","query","sep","httpToWsProtocol","url","mappings","http","https","from","to","Error","join","joinPair","b","cleanA","replace","cleanB","current","next"],"mappings":"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","sourcesContent":["// Creates a dictionary of parameters based on the given query string. q should\n// look like \"?foo=bar&thing=blah\".\nexport function parseQueryString(q) {\n  if (!q || !q.length) {\n    return {};\n  }\n\n  // Array of key/value pairs\n  const args = q\n    .substr(1)\n    .split(\"&\")\n    .map(parseArg);\n\n  // Convert to object\n  return args.reduce((result, arg) => {\n    result[arg.key] = arg.value;\n    return result;\n  }, {});\n}\n\n// Converts \"asdf=qwer\" to { asdf: \"qwer\" } or \"asdf\" to { asdf: true }. The\n// latter example is to allow switch-like parameters like ?enableThing without\n// an equals sign.\nfunction parseArg(a) {\n  const parts = a.split(\"=\");\n  const key = parts[0];\n  const value = parts[1] === undefined ? true : decodeURIComponent(parts[1]);\n  return { key, value };\n}\n\n// Converts { a: \"aaa\", b: \"bbb\" } to \"?a=aaa&b=bbb\"\nexport function makeQueryString(query) {\n  if (!query) {\n    return \"\";\n  }\n\n  let sep = \"?\";\n  let result = \"\";\n\n  for (const key in query) {\n    const value = query[key];\n    result += `${sep}${key}=${value}`;\n    sep = \"&\";\n  }\n  return result;\n}\n\n// Converts http://foo to ws://foo or https://foo to wss://foo\nexport function httpToWsProtocol(url) {\n  const mappings = {\n    http: \"ws\",\n    https: \"wss\"\n  };\n\n  for (const from in mappings) {\n    const to = mappings[from];\n    if (url.substr(0, from.length + 1) === from + \":\") {\n      return to + url.substr(from.length);\n    }\n  }\n\n  throw new Error(\"Invalid URL: \" + url);\n}\n\n// Joins path components and makes sure there is exactly one '/' separating\n// them.\nexport function join(...parts) {\n  function joinPair(a, b) {\n    const cleanA = a.replace(/\\/+$/, \"\");\n    const cleanB = b.replace(/^\\/+/, \"\");\n\n    if (cleanA === \"\") {\n      return cleanB;\n    }\n\n    if (cleanB === \"\") {\n      return cleanA;\n    }\n\n    return `${cleanA}/${cleanB}`;\n  }\n\n  return parts.reduce((current, next) => joinPair(current, next), \"\");\n}\n"]},"metadata":{},"sourceType":"module"}