{"ast":null,"code":"import _regeneratorRuntime from\"/Users/yabu/CC/board/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/yabu/CC/board/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";/**\n * This file contains helper functions for async loading svg files that\n * can be injected inline into an html <svg> element. This is better than\n * alternatives for the following reasons:\n *\n *    <use href=\"...\"> has a problem where the game could start before the\n *    svg has finished loading whereas this method gives a promise we can wait\n *    for.\n *\n *    <image src=\"...\"> has a problem where the fill color of the image cannot\n *    be overriden. Inline svg solves this problem and allows css styles to\n *    cascade into the svg content. <use> may also have this problem?\n *\n *    Directly embedding the svg xml into react components (or similar) would\n *    mostly solve everything except that it eliminates the possibility of\n *    pulling in svg data from external trusted sources.\n *\n * The main downside to this method is that the source of the svg must be\n * trusted or else you are vulnerable to xss attacks.\n */var loaded={};var doesntExist={};export function loadSvgs(paths){return Promise.all(paths.map(requireSvg));}export function getSvg(path){return loaded[path];}function requireSvg(path){if(path in loaded){return Promise.resolve(loaded[path]);}return fetchSvg(path);}function fetchSvg(_x){return _fetchSvg.apply(this,arguments);}function _fetchSvg(){_fetchSvg=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(path){var response,svgText,svg;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return fetch(path);case 2:response=_context.sent;_context.next=5;return response.text();case 5:svgText=_context.sent;svg=makeDom(svgText);loaded[path]=svg;return _context.abrupt(\"return\",svg);case 9:case\"end\":return _context.stop();}}},_callee);}));return _fetchSvg.apply(this,arguments);}function makeDom(svgText){var wrapper=document.createElement(\"div\");wrapper.innerHTML=svgText.trim();return wrapper.firstChild;}export function svgExists(_x2){return _svgExists.apply(this,arguments);}function _svgExists(){_svgExists=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path){var response,svgText,exists;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!(path in loaded)){_context2.next=2;break;}return _context2.abrupt(\"return\",true);case 2:if(!(path in doesntExist)){_context2.next=4;break;}return _context2.abrupt(\"return\",false);case 4:_context2.prev=4;_context2.next=7;return fetch(path);case 7:response=_context2.sent;_context2.next=10;return response.text();case 10:svgText=_context2.sent;exists=svgText.startsWith(\"<svg\");if(!exists){doesntExist[path]=true;}return _context2.abrupt(\"return\",exists);case 16:_context2.prev=16;_context2.t0=_context2[\"catch\"](4);//Most likely a CORS issue for a specific svg\nconsole.warn(_context2.t0,path,\"Fallback to default\");return _context2.abrupt(\"return\",false);case 20:case\"end\":return _context2.stop();}}},_callee2,null,[[4,16]]);}));return _svgExists.apply(this,arguments);}","map":{"version":3,"sources":["/Users/yabu/CC/board/src/utils/inline-svg.js"],"names":["loaded","doesntExist","loadSvgs","paths","Promise","all","map","requireSvg","getSvg","path","resolve","fetchSvg","fetch","response","text","svgText","svg","makeDom","wrapper","document","createElement","innerHTML","trim","firstChild","svgExists","exists","startsWith","console","warn"],"mappings":"2MAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA,GAAMA,CAAAA,MAAM,CAAG,EAAf,CACA,GAAMC,CAAAA,WAAW,CAAG,EAApB,CAEA,MAAO,SAASC,CAAAA,QAAT,CAAkBC,KAAlB,CAAyB,CAC9B,MAAOC,CAAAA,OAAO,CAACC,GAAR,CAAYF,KAAK,CAACG,GAAN,CAAUC,UAAV,CAAZ,CAAP,CACD,CAED,MAAO,SAASC,CAAAA,MAAT,CAAgBC,IAAhB,CAAsB,CAC3B,MAAOT,CAAAA,MAAM,CAACS,IAAD,CAAb,CACD,CAED,QAASF,CAAAA,UAAT,CAAoBE,IAApB,CAA0B,CACxB,GAAIA,IAAI,GAAIT,CAAAA,MAAZ,CAAoB,CAClB,MAAOI,CAAAA,OAAO,CAACM,OAAR,CAAgBV,MAAM,CAACS,IAAD,CAAtB,CAAP,CACD,CAED,MAAOE,CAAAA,QAAQ,CAACF,IAAD,CAAf,CACD,C,QAEcE,CAAAA,Q,oIAAf,iBAAwBF,IAAxB,iKACyBG,CAAAA,KAAK,CAACH,IAAD,CAD9B,QACQI,QADR,qCAEwBA,CAAAA,QAAQ,CAACC,IAAT,EAFxB,QAEQC,OAFR,eAGQC,GAHR,CAGcC,OAAO,CAACF,OAAD,CAHrB,CAIEf,MAAM,CAACS,IAAD,CAAN,CAAeO,GAAf,CAJF,gCAKSA,GALT,wD,2CAQA,QAASC,CAAAA,OAAT,CAAiBF,OAAjB,CAA0B,CACxB,GAAMG,CAAAA,OAAO,CAAGC,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAhB,CACAF,OAAO,CAACG,SAAR,CAAoBN,OAAO,CAACO,IAAR,EAApB,CACA,MAAOJ,CAAAA,OAAO,CAACK,UAAf,CACD,CAED,eAAsBC,CAAAA,SAAtB,+C,yFAAO,kBAAyBf,IAAzB,uJACDA,IAAI,GAAIT,CAAAA,MADP,4DAEI,IAFJ,cAIDS,IAAI,GAAIR,CAAAA,WAJP,4DAKI,KALJ,iDASoBW,CAAAA,KAAK,CAACH,IAAD,CATzB,QASGI,QATH,wCAUmBA,CAAAA,QAAQ,CAACC,IAAT,EAVnB,SAUGC,OAVH,gBAWGU,MAXH,CAWYV,OAAO,CAACW,UAAR,CAAmB,MAAnB,CAXZ,CAYH,GAAI,CAACD,MAAL,CAAa,CACXxB,WAAW,CAACQ,IAAD,CAAX,CAAoB,IAApB,CACD,CAdE,iCAeIgB,MAfJ,+DAiBH;AACAE,OAAO,CAACC,IAAR,cAAgBnB,IAAhB,CAAsB,qBAAtB,EAlBG,iCAmBI,KAnBJ,yE","sourcesContent":["/**\n * This file contains helper functions for async loading svg files that\n * can be injected inline into an html <svg> element. This is better than\n * alternatives for the following reasons:\n *\n *    <use href=\"...\"> has a problem where the game could start before the\n *    svg has finished loading whereas this method gives a promise we can wait\n *    for.\n *\n *    <image src=\"...\"> has a problem where the fill color of the image cannot\n *    be overriden. Inline svg solves this problem and allows css styles to\n *    cascade into the svg content. <use> may also have this problem?\n *\n *    Directly embedding the svg xml into react components (or similar) would\n *    mostly solve everything except that it eliminates the possibility of\n *    pulling in svg data from external trusted sources.\n *\n * The main downside to this method is that the source of the svg must be\n * trusted or else you are vulnerable to xss attacks.\n */\n\nconst loaded = {};\nconst doesntExist = {};\n\nexport function loadSvgs(paths) {\n  return Promise.all(paths.map(requireSvg));\n}\n\nexport function getSvg(path) {\n  return loaded[path];\n}\n\nfunction requireSvg(path) {\n  if (path in loaded) {\n    return Promise.resolve(loaded[path]);\n  }\n\n  return fetchSvg(path);\n}\n\nasync function fetchSvg(path) {\n  const response = await fetch(path);\n  const svgText = await response.text();\n  const svg = makeDom(svgText);\n  loaded[path] = svg;\n  return svg;\n}\n\nfunction makeDom(svgText) {\n  const wrapper = document.createElement(\"div\");\n  wrapper.innerHTML = svgText.trim();\n  return wrapper.firstChild;\n}\n\nexport async function svgExists(path) {\n  if (path in loaded) {\n    return true;\n  }\n  if (path in doesntExist) {\n    return false;\n  }\n  //not cached yet\n  try {\n    const response = await fetch(path);\n    const svgText = await response.text();\n    const exists = svgText.startsWith(\"<svg\");\n    if (!exists) {\n      doesntExist[path] = true;\n    }\n    return exists;\n  } catch (e) {\n    //Most likely a CORS issue for a specific svg\n    console.warn(e, path, \"Fallback to default\");\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}