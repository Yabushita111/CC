{"ast":null,"code":"import { streamAll } from \"../io/websocket\";\nimport { makeQueryString, httpToWsProtocol, join } from \"./url\";\nimport { loadSvgs, getSvg, svgExists } from \"./inline-svg\";\nconst DEFAULT_SNAKE_HEAD = \"default\";\nconst DEFAULT_SNAKE_TAIL = \"default\";\nconst APP_VERSION = process.env.REACT_APP_VERSION;\n\nasync function get(url, query) {\n  const response = await fetch(url + makeQueryString(query));\n  const u = url + makeQueryString(query);\n  console.log(u);\n\n  if (response.status === 200) {\n    return Promise.resolve(response.json());\n  } else {\n    return Promise.resolve(response.json()).then(responseJson => {\n      console.error(responseJson.error);\n      return Promise.reject(responseJson.error);\n    });\n  }\n}\n\nexport function delay(millis) {\n  return new Promise(resolve => setTimeout(resolve, millis));\n}\nexport function getReadableCauseOfDeath(death) {\n  // See https://github.com/BattlesnakeOfficial/rules/blob/master/standard.go\n  switch (death.cause) {\n    case \"snake-collision\":\n      return `Ran into ${death.eliminatedBy}'s body`;\n\n    case \"snake-self-collision\":\n      return \"Collided with itself\";\n\n    case \"out-of-health\":\n      return \"Out of health\";\n\n    case \"hazard\":\n      return \"Eliminated by hazard\";\n\n    case \"head-collision\":\n      return `Lost head-to-head with ${death.eliminatedBy}`;\n\n    case \"wall-collision\":\n      return \"Moved out of bounds\";\n\n    case \"squad-eliminated\":\n      return \"Squad was eliminated\";\n\n    default:\n      return death.cause;\n  }\n} // Gets a list of all unique SVG paths required by the snakes.\n\nfunction getAllSvgs(snakes) {\n  const all = snakes.reduce((result, snake) => {\n    return result.concat([snake.HeadType, snake.TailType]);\n  }, []);\n  const unique = new Set(all);\n  return Array.from(unique);\n}\n\nasync function assignHeadAndTailUrls(snakes) {\n  for (const snake of snakes) {\n    // Assign default if missing\n    if (!snake.HeadType) {\n      snake.HeadType = DEFAULT_SNAKE_HEAD;\n    }\n\n    if (!snake.TailType) {\n      snake.TailType = DEFAULT_SNAKE_TAIL;\n    } // Format as actual URL if it's just a name\n\n\n    snake.HeadType = getSnakeHeadSvgUrl(snake.HeadType);\n    snake.TailType = getSnakeTailSvgUrl(snake.TailType);\n\n    if (!(await svgExists(snake.HeadType))) {\n      snake.HeadType = getSnakeHeadSvgUrl(DEFAULT_SNAKE_HEAD);\n    }\n\n    if (!(await svgExists(snake.TailType))) {\n      snake.TailType = getSnakeTailSvgUrl(DEFAULT_SNAKE_TAIL);\n    }\n  }\n}\n\nasync function setHeadAndTailSvgs(snakes) {\n  await assignHeadAndTailUrls(snakes);\n  await loadSvgs(getAllSvgs(snakes));\n\n  for (const snake of snakes) {\n    snake.HeadSvg = getSvg(snake.HeadType);\n    snake.TailSvg = getSvg(snake.TailType);\n  }\n}\n\nfunction isIllegalSvgPath(nameOrPath) {\n  return nameOrPath.indexOf(\"/\") >= 0 || nameOrPath.indexOf(\".\") >= 0;\n}\n\nfunction svgUrlFromName(base, relative) {\n  //appending the git hash of this version allows for cache busting on deploy\n  const extension = \".svg?board_version=\" + APP_VERSION;\n  return join(\"https://media.battlesnake.com\", base, relative) + extension;\n}\n\nfunction getSnakeHeadSvgUrl(path) {\n  const effectivePath = isIllegalSvgPath(path) ? DEFAULT_SNAKE_HEAD : path;\n  return svgUrlFromName(\"/snakes/heads\", effectivePath);\n}\n\nfunction getSnakeTailSvgUrl(path) {\n  const effectivePath = isIllegalSvgPath(path) ? DEFAULT_SNAKE_TAIL : path;\n  return svgUrlFromName(\"/snakes/tails\", effectivePath);\n}\n\nasync function prepareFrame(frame) {\n  await setHeadAndTailSvgs(frame.Snakes);\n}\n\nexport function fetchGameInfo(baseUrl, gameId) {\n  const url = join(baseUrl, `games/${gameId}`);\n  console.log(\"output:\");\n  console.log(url);\n  return get(url);\n}\nexport async function streamAllEvents(baseUrl, gameId, receiveEvent) {\n  const game = await fetchGameInfo(baseUrl, gameId);\n  console.log(game);\n  let chain = Promise.resolve();\n\n  function onEngineEvent(engineEvent) {\n    if (engineEvent.Type) {\n      const eventData = engineEvent.Data || engineEvent; //output eventdata\n\n      console.log(eventData);\n      chain = chain.then(async () => {\n        if (engineEvent.Type === \"frame\") {\n          await prepareFrame(eventData);\n        }\n\n        return receiveEvent(game, engineEvent.Type, eventData);\n      });\n    }\n\n    return engineEvent.Type && engineEvent.Type === \"game_end\";\n  }\n\n  const wsUrl = join(httpToWsProtocol(baseUrl), `games/${gameId}/events`);\n  console.log(wsUrl);\n  await streamAll(wsUrl, onEngineEvent);\n  await chain;\n}\nexport function getFrameByTurn(frames, turn) {\n  return frames.filter(frame => frame.turn === turn)[0];\n}","map":{"version":3,"sources":["/Users/yabu/board/src/utils/engine-client.js"],"names":["streamAll","makeQueryString","httpToWsProtocol","join","loadSvgs","getSvg","svgExists","DEFAULT_SNAKE_HEAD","DEFAULT_SNAKE_TAIL","APP_VERSION","process","env","REACT_APP_VERSION","get","url","query","response","fetch","u","console","log","status","Promise","resolve","json","then","responseJson","error","reject","delay","millis","setTimeout","getReadableCauseOfDeath","death","cause","eliminatedBy","getAllSvgs","snakes","all","reduce","result","snake","concat","HeadType","TailType","unique","Set","Array","from","assignHeadAndTailUrls","getSnakeHeadSvgUrl","getSnakeTailSvgUrl","setHeadAndTailSvgs","HeadSvg","TailSvg","isIllegalSvgPath","nameOrPath","indexOf","svgUrlFromName","base","relative","extension","path","effectivePath","prepareFrame","frame","Snakes","fetchGameInfo","baseUrl","gameId","streamAllEvents","receiveEvent","game","chain","onEngineEvent","engineEvent","Type","eventData","Data","wsUrl","getFrameByTurn","frames","turn","filter"],"mappings":"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","sourcesContent":["import { streamAll } from \"../io/websocket\";\nimport { makeQueryString, httpToWsProtocol, join } from \"./url\";\nimport { loadSvgs, getSvg, svgExists } from \"./inline-svg\";\n\nconst DEFAULT_SNAKE_HEAD = \"default\";\nconst DEFAULT_SNAKE_TAIL = \"default\";\nconst APP_VERSION = process.env.REACT_APP_VERSION;\n\nasync function get(url, query) {\n  const response = await fetch(url + makeQueryString(query));\n  const u = url + makeQueryString(query);\n  console.log(u);\n  if (response.status === 200) {\n    return Promise.resolve(response.json());\n  } else {\n    return Promise.resolve(response.json()).then(responseJson => {\n      console.error(responseJson.error);\n      return Promise.reject(responseJson.error);\n    });\n  }\n}\n\nexport function delay(millis) {\n  return new Promise(resolve => setTimeout(resolve, millis));\n}\n\nexport function getReadableCauseOfDeath(death) {\n  // See https://github.com/BattlesnakeOfficial/rules/blob/master/standard.go\n  switch (death.cause) {\n    case \"snake-collision\":\n      return `Ran into ${death.eliminatedBy}'s body`;\n    case \"snake-self-collision\":\n      return \"Collided with itself\";\n    case \"out-of-health\":\n      return \"Out of health\";\n    case \"hazard\":\n      return \"Eliminated by hazard\";\n    case \"head-collision\":\n      return `Lost head-to-head with ${death.eliminatedBy}`;\n    case \"wall-collision\":\n      return \"Moved out of bounds\";\n    case \"squad-eliminated\":\n      return \"Squad was eliminated\";\n    default:\n      return death.cause;\n  }\n}\n\n// Gets a list of all unique SVG paths required by the snakes.\nfunction getAllSvgs(snakes) {\n  const all = snakes.reduce((result, snake) => {\n    return result.concat([snake.HeadType, snake.TailType]);\n  }, []);\n  const unique = new Set(all);\n  return Array.from(unique);\n}\n\nasync function assignHeadAndTailUrls(snakes) {\n  for (const snake of snakes) {\n    // Assign default if missing\n    if (!snake.HeadType) {\n      snake.HeadType = DEFAULT_SNAKE_HEAD;\n    }\n    if (!snake.TailType) {\n      snake.TailType = DEFAULT_SNAKE_TAIL;\n    }\n\n    // Format as actual URL if it's just a name\n    snake.HeadType = getSnakeHeadSvgUrl(snake.HeadType);\n    snake.TailType = getSnakeTailSvgUrl(snake.TailType);\n\n    if (!(await svgExists(snake.HeadType))) {\n      snake.HeadType = getSnakeHeadSvgUrl(DEFAULT_SNAKE_HEAD);\n    }\n    if (!(await svgExists(snake.TailType))) {\n      snake.TailType = getSnakeTailSvgUrl(DEFAULT_SNAKE_TAIL);\n    }\n  }\n}\n\nasync function setHeadAndTailSvgs(snakes) {\n  await assignHeadAndTailUrls(snakes);\n  await loadSvgs(getAllSvgs(snakes));\n\n  for (const snake of snakes) {\n    snake.HeadSvg = getSvg(snake.HeadType);\n    snake.TailSvg = getSvg(snake.TailType);\n  }\n}\n\nfunction isIllegalSvgPath(nameOrPath) {\n  return nameOrPath.indexOf(\"/\") >= 0 || nameOrPath.indexOf(\".\") >= 0;\n}\n\nfunction svgUrlFromName(base, relative) {\n  //appending the git hash of this version allows for cache busting on deploy\n  const extension = \".svg?board_version=\" + APP_VERSION;\n  return join(\"https://media.battlesnake.com\", base, relative) + extension;\n}\n\nfunction getSnakeHeadSvgUrl(path) {\n  const effectivePath = isIllegalSvgPath(path) ? DEFAULT_SNAKE_HEAD : path;\n  return svgUrlFromName(\"/snakes/heads\", effectivePath);\n}\n\nfunction getSnakeTailSvgUrl(path) {\n  const effectivePath = isIllegalSvgPath(path) ? DEFAULT_SNAKE_TAIL : path;\n  return svgUrlFromName(\"/snakes/tails\", effectivePath);\n}\n\nasync function prepareFrame(frame) {\n  await setHeadAndTailSvgs(frame.Snakes);\n}\n\nexport function fetchGameInfo(baseUrl, gameId) {\n  const url = join(baseUrl, `games/${gameId}`);\n  console.log(\"output:\");\n  console.log(url);\n  return get(url);\n}\n\nexport async function streamAllEvents(baseUrl, gameId, receiveEvent) {\n  const game = await fetchGameInfo(baseUrl, gameId);\n  console.log(game);\n  let chain = Promise.resolve();\n  function onEngineEvent(engineEvent) {\n    if (engineEvent.Type) {\n      const eventData = engineEvent.Data || engineEvent;\n      //output eventdata\n      console.log(eventData);\n      chain = chain.then(async () => {\n        if (engineEvent.Type === \"frame\") {\n          await prepareFrame(eventData);\n        }\n        return receiveEvent(game, engineEvent.Type, eventData);\n      });\n    }\n    return engineEvent.Type && engineEvent.Type === \"game_end\";\n  }\n\n  const wsUrl = join(httpToWsProtocol(baseUrl), `games/${gameId}/events`);\n  console.log(wsUrl);\n  await streamAll(wsUrl, onEngineEvent);\n  await chain;\n}\nexport function getFrameByTurn(frames, turn) {\n  return frames.filter(frame => frame.turn === turn)[0];\n}\n"]},"metadata":{},"sourceType":"module"}