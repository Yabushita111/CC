{"ast":null,"code":"// Creates a dictionary of parameters based on the given query string. q should\n// look like \"?foo=bar&thing=blah\".\nexport function parseQueryString(q) {\n  //?game_idでアクセス可能\n  const href = window.location.href;\n  args['engine'] = href.substr(0, href.lastIndexOf('/') + 1); // Convert to object\n\n  return args.reduce((result, arg) => {\n    result[arg.key] = arg.value;\n    return result;\n  }, {});\n} // Converts { a: \"aaa\", b: \"bbb\" } to \"?a=aaa&b=bbb\"\n\nexport function makeQueryString(query) {\n  if (!query) {\n    return \"\";\n  }\n\n  let sep = \"?\";\n  let result = \"\";\n\n  for (const key in query) {\n    const value = query[key];\n    result += `${sep}${key}=${value}`;\n    sep = \"&\";\n  }\n\n  return result;\n} // Converts http://foo to ws://foo or https://foo to wss://foo\n\nexport function httpToWsProtocol(url) {\n  const mappings = {\n    http: \"ws\",\n    https: \"wss\"\n  };\n\n  for (const from in mappings) {\n    const to = mappings[from];\n\n    if (url.substr(0, from.length + 1) === from + \":\") {\n      return to + url.substr(from.length);\n    }\n  }\n\n  throw new Error(\"Invalid URL: \" + url);\n} // Joins path components and makes sure there is exactly one '/' separating\n// them.\n\nexport function join(...parts) {\n  function joinPair(a, b) {\n    const cleanA = a.replace(/\\/+$/, \"\");\n    const cleanB = b.replace(/^\\/+/, \"\");\n\n    if (cleanA === \"\") {\n      return cleanB;\n    }\n\n    if (cleanB === \"\") {\n      return cleanA;\n    }\n\n    return `${cleanA}/${cleanB}`;\n  }\n\n  return parts.reduce((current, next) => joinPair(current, next), \"\");\n}","map":{"version":3,"sources":["/home/y-yabust/CC/cc-replay/src/utils/url.js"],"names":["parseQueryString","q","href","window","location","args","substr","lastIndexOf","reduce","result","arg","key","value","makeQueryString","query","sep","httpToWsProtocol","url","mappings","http","https","from","to","length","Error","join","parts","joinPair","a","b","cleanA","replace","cleanB","current","next"],"mappings":"AAAA;AACA;AACA,OAAO,SAASA,gBAAT,CAA0BC,CAA1B,EAA6B;AAClC;AACA,QAAMC,IAAI,GAAGC,MAAM,CAACC,QAAP,CAAgBF,IAA7B;AACAG,EAAAA,IAAI,CAAC,QAAD,CAAJ,GAAiBH,IAAI,CAACI,MAAL,CAAY,CAAZ,EAAcJ,IAAI,CAACK,WAAL,CAAiB,GAAjB,IAAsB,CAApC,CAAjB,CAHkC,CAKlC;;AACA,SAAOF,IAAI,CAACG,MAAL,CAAY,CAACC,MAAD,EAASC,GAAT,KAAiB;AAClCD,IAAAA,MAAM,CAACC,GAAG,CAACC,GAAL,CAAN,GAAkBD,GAAG,CAACE,KAAtB;AACA,WAAOH,MAAP;AACD,GAHM,EAGJ,EAHI,CAAP;AAID,C,CACD;;AACA,OAAO,SAASI,eAAT,CAAyBC,KAAzB,EAAgC;AACrC,MAAI,CAACA,KAAL,EAAY;AACV,WAAO,EAAP;AACD;;AAED,MAAIC,GAAG,GAAG,GAAV;AACA,MAAIN,MAAM,GAAG,EAAb;;AAEA,OAAK,MAAME,GAAX,IAAkBG,KAAlB,EAAyB;AACvB,UAAMF,KAAK,GAAGE,KAAK,CAACH,GAAD,CAAnB;AACAF,IAAAA,MAAM,IAAK,GAAEM,GAAI,GAAEJ,GAAI,IAAGC,KAAM,EAAhC;AACAG,IAAAA,GAAG,GAAG,GAAN;AACD;;AACD,SAAON,MAAP;AACD,C,CAED;;AACA,OAAO,SAASO,gBAAT,CAA0BC,GAA1B,EAA+B;AACpC,QAAMC,QAAQ,GAAG;AACfC,IAAAA,IAAI,EAAE,IADS;AAEfC,IAAAA,KAAK,EAAE;AAFQ,GAAjB;;AAKA,OAAK,MAAMC,IAAX,IAAmBH,QAAnB,EAA6B;AAC3B,UAAMI,EAAE,GAAGJ,QAAQ,CAACG,IAAD,CAAnB;;AACA,QAAIJ,GAAG,CAACX,MAAJ,CAAW,CAAX,EAAce,IAAI,CAACE,MAAL,GAAc,CAA5B,MAAmCF,IAAI,GAAG,GAA9C,EAAmD;AACjD,aAAOC,EAAE,GAAGL,GAAG,CAACX,MAAJ,CAAWe,IAAI,CAACE,MAAhB,CAAZ;AACD;AACF;;AAED,QAAM,IAAIC,KAAJ,CAAU,kBAAkBP,GAA5B,CAAN;AACD,C,CAED;AACA;;AACA,OAAO,SAASQ,IAAT,CAAc,GAAGC,KAAjB,EAAwB;AAC7B,WAASC,QAAT,CAAkBC,CAAlB,EAAqBC,CAArB,EAAwB;AACtB,UAAMC,MAAM,GAAGF,CAAC,CAACG,OAAF,CAAU,MAAV,EAAkB,EAAlB,CAAf;AACA,UAAMC,MAAM,GAAGH,CAAC,CAACE,OAAF,CAAU,MAAV,EAAkB,EAAlB,CAAf;;AAEA,QAAID,MAAM,KAAK,EAAf,EAAmB;AACjB,aAAOE,MAAP;AACD;;AAED,QAAIA,MAAM,KAAK,EAAf,EAAmB;AACjB,aAAOF,MAAP;AACD;;AAED,WAAQ,GAAEA,MAAO,IAAGE,MAAO,EAA3B;AACD;;AAED,SAAON,KAAK,CAAClB,MAAN,CAAa,CAACyB,OAAD,EAAUC,IAAV,KAAmBP,QAAQ,CAACM,OAAD,EAAUC,IAAV,CAAxC,EAAyD,EAAzD,CAAP;AACD","sourcesContent":["// Creates a dictionary of parameters based on the given query string. q should\n// look like \"?foo=bar&thing=blah\".\nexport function parseQueryString(q) {\n  //?game_idでアクセス可能\n  const href = window.location.href;\n  args['engine'] = href.substr(0,href.lastIndexOf('/')+1);\n\n  // Convert to object\n  return args.reduce((result, arg) => {\n    result[arg.key] = arg.value;\n    return result;\n  }, {});\n}\n// Converts { a: \"aaa\", b: \"bbb\" } to \"?a=aaa&b=bbb\"\nexport function makeQueryString(query) {\n  if (!query) {\n    return \"\";\n  }\n\n  let sep = \"?\";\n  let result = \"\";\n\n  for (const key in query) {\n    const value = query[key];\n    result += `${sep}${key}=${value}`;\n    sep = \"&\";\n  }\n  return result;\n}\n\n// Converts http://foo to ws://foo or https://foo to wss://foo\nexport function httpToWsProtocol(url) {\n  const mappings = {\n    http: \"ws\",\n    https: \"wss\"\n  };\n\n  for (const from in mappings) {\n    const to = mappings[from];\n    if (url.substr(0, from.length + 1) === from + \":\") {\n      return to + url.substr(from.length);\n    }\n  }\n\n  throw new Error(\"Invalid URL: \" + url);\n}\n\n// Joins path components and makes sure there is exactly one '/' separating\n// them.\nexport function join(...parts) {\n  function joinPair(a, b) {\n    const cleanA = a.replace(/\\/+$/, \"\");\n    const cleanB = b.replace(/^\\/+/, \"\");\n\n    if (cleanA === \"\") {\n      return cleanB;\n    }\n\n    if (cleanB === \"\") {\n      return cleanA;\n    }\n\n    return `${cleanA}/${cleanB}`;\n  }\n\n  return parts.reduce((current, next) => joinPair(current, next), \"\");\n}\n"]},"metadata":{},"sourceType":"module"}