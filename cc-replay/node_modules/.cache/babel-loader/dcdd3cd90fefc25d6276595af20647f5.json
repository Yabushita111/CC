{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/y-yabust/CC/cc-replay/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import cloneDeep from\"lodash.clonedeep\";var DEFAULT_DIRECTION=\"right\";var TYPE_HEAD=\"head\";var TYPE_TAIL=\"tail\";var TYPE_BODY=\"body\";export function formatFrame(frame){cleanFrame(frame);var snakes=formatSnakes(frame.Snakes);return{turn:frame.Turn,snakes:snakes,food:formatPositions(frame.Food),hazards:formatPositions(frame.Hazards)};}export function sanitizeFrame(frame){// Copy without reference\nvar sanitizedFrame=cloneDeep(frame);// nullify some fields\nfor(var i in sanitizedFrame.snakes){var snake=sanitizedFrame.snakes[i];snake.id=snake._id;delete snake._id;delete snake.headSvg;delete snake.tailSvg;}return sanitizedFrame;}function formatSnakes(snakes){if(snakes){var newSnakes=snakes.map(formatSnake);// Populate eliminatedBy names\nnewSnakes.forEach(function(snake,index){if(snake.death&&snake.death.eliminatedBy&&snake.death.eliminatedBy.length>0){for(var i in newSnakes){if(newSnakes[i]._id===snake.death.eliminatedBy){newSnakes[index].death.eliminatedBy=newSnakes[i].name;break;}}}});return newSnakes;}}function formatSnake(snake){var renderedParts=snake.Body.filter(function(_,i){return shouldRenderPart(snake,i);});return{body:snake.Body.map(function(_,i){return formatSnakePart(snake,i);}),color:snake.Color,_id:snake.ID,name:snake.Name,effectiveSpace:renderedParts.length,health:snake.Health,latency:snake.Latency,error:snake.Error,timing:snake.TimingMicros,isDead:!!snake.Death,death:formatDeath(snake.Death),head:snake.HeadType&&snake.HeadType.toLowerCase(),tail:snake.TailType&&snake.TailType.toLowerCase(),headSvg:snake.HeadSvg,tailSvg:snake.TailSvg,squad:snake.Squad,author:snake.Author,shout:snake.Shout};}function formatDeath(death){if(!death){return;}return{cause:death.Cause,turn:death.Turn||0,eliminatedBy:death.EliminatedBy};}function shouldRenderPart(snake,partIndex){var headIndex=0;var tailIndex=snake.Body.length-1;var head=snake.Body[headIndex];var tail=snake.Body[tailIndex];var currPart=snake.Body[partIndex];// always render head\nif(partIndex===headIndex){return true;}// render tail if not covered by head\nif(partIndex===tailIndex){return!(head.X===currPart.X&&head.Y===currPart.Y);}// render middle part if it's in a different position than\n// the next piece closer to head, and not in same spot as tail\nvar nextPart=snake.Body[partIndex-1];return!(tail.X===currPart.X&&tail.Y===currPart.Y)&&!(head.X===currPart.X&&head.Y===currPart.Y)&&!(nextPart&&nextPart.X===currPart.X&&nextPart.Y===currPart.Y);}function formatSnakePart(snake,partIndex){var part=snake.Body[partIndex];var type=getType(snake,partIndex);var _formatPosition=formatPosition(part),x=_formatPosition.x,y=_formatPosition.y;var direction=formatDirection(type,snake,part,partIndex);var isOverlapped=!shouldRenderPart(snake,partIndex)?true:undefined;return{direction:direction,type:type,isOverlapped:isOverlapped,x:x,y:y};}function formatPositions(positions){if(positions){return positions.map(formatPosition);}}function formatPosition(pos){return{x:pos.X,y:pos.Y};}function formatDirection(type,snake,part,partIndex){var direction;if(type===\"head\"){direction=getDirection(snake.Body[1],snake.Body[0]);}else{// handle special case where parts overlap\nvar prevPart;do{prevPart=snake.Body[Math.max(partIndex-1,0)];--partIndex;}while(partIndex>0&&prevPart.X===part.X&&prevPart.Y===part.Y);direction=getDirection(part,prevPart);}return direction;}function getDirection(a,b){if(a&&b){// Handle cases where b is one move after a\nif(a.X+1===b.X){return\"right\";}else if(a.X-1===b.X){return\"left\";}else if(a.Y+1===b.Y){return\"up\";}else if(a.Y-1===b.Y){return\"down\";}// Handle wrapped cases (we can anchor against one part being on 0 axis)\nif(a.X>b.X&&b.X===0){return\"right\";}else if(a.X<b.X&&a.X===0){return\"left\";}else if(a.Y>b.Y&&b.Y===0){return\"up\";}else if(a.Y<b.Y&&a.Y===0){return\"down\";}}return DEFAULT_DIRECTION;}function getType(snake,partIndex){if(partIndex===0){return TYPE_HEAD;}if(partIndex===snake.Body.length-1){return TYPE_TAIL;}return TYPE_BODY;}// This is a workaround for fields that are omitted when they have the default\n// value. ie: int fields that need to default to 0 rather than undefined.\nfunction cleanFrame(frame){frame.Turn=frame.Turn||0;var _iterator=_createForOfIteratorHelper(frame.Snakes),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var snake=_step.value;var _iterator3=_createForOfIteratorHelper(snake.Body),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var part=_step3.value;part.X=part.X||0;part.Y=part.Y||0;}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}}catch(err){_iterator.e(err);}finally{_iterator.f();}var _iterator2=_createForOfIteratorHelper(frame.Food),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var food=_step2.value;food.X=food.X||0;food.Y=food.Y||0;}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}","map":{"version":3,"sources":["/home/y-yabust/CC/cc-replay/src/utils/game-state.js"],"names":["cloneDeep","DEFAULT_DIRECTION","TYPE_HEAD","TYPE_TAIL","TYPE_BODY","formatFrame","frame","cleanFrame","snakes","formatSnakes","Snakes","turn","Turn","food","formatPositions","Food","hazards","Hazards","sanitizeFrame","sanitizedFrame","i","snake","id","_id","headSvg","tailSvg","newSnakes","map","formatSnake","forEach","index","death","eliminatedBy","length","name","renderedParts","Body","filter","_","shouldRenderPart","body","formatSnakePart","color","Color","ID","Name","effectiveSpace","health","Health","latency","Latency","error","Error","timing","TimingMicros","isDead","Death","formatDeath","head","HeadType","toLowerCase","tail","TailType","HeadSvg","TailSvg","squad","Squad","author","Author","shout","Shout","cause","Cause","EliminatedBy","partIndex","headIndex","tailIndex","currPart","X","Y","nextPart","part","type","getType","formatPosition","x","y","direction","formatDirection","isOverlapped","undefined","positions","pos","getDirection","prevPart","Math","max","a","b"],"mappings":"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","sourcesContent":["import cloneDeep from \"lodash.clonedeep\";\n\nconst DEFAULT_DIRECTION = \"right\";\n\nconst TYPE_HEAD = \"head\";\nconst TYPE_TAIL = \"tail\";\nconst TYPE_BODY = \"body\";\n\nexport function formatFrame(frame) {\n  cleanFrame(frame);\n  const snakes = formatSnakes(frame.Snakes);\n  return {\n    turn: frame.Turn,\n    snakes: snakes,\n    food: formatPositions(frame.Food),\n    hazards: formatPositions(frame.Hazards)\n  };\n}\n\nexport function sanitizeFrame(frame) {\n  // Copy without reference\n  const sanitizedFrame = cloneDeep(frame);\n\n  // nullify some fields\n  for (const i in sanitizedFrame.snakes) {\n    const snake = sanitizedFrame.snakes[i];\n    snake.id = snake._id;\n    delete snake._id;\n\n    delete snake.headSvg;\n    delete snake.tailSvg;\n  }\n\n  return sanitizedFrame;\n}\n\nfunction formatSnakes(snakes) {\n  if (snakes) {\n    let newSnakes = snakes.map(formatSnake);\n\n    // Populate eliminatedBy names\n    newSnakes.forEach(function(snake, index) {\n      if (\n        snake.death &&\n        snake.death.eliminatedBy &&\n        snake.death.eliminatedBy.length > 0\n      ) {\n        for (const i in newSnakes) {\n          if (newSnakes[i]._id === snake.death.eliminatedBy) {\n            newSnakes[index].death.eliminatedBy = newSnakes[i].name;\n            break;\n          }\n        }\n      }\n    });\n    return newSnakes;\n  }\n}\n\nfunction formatSnake(snake) {\n  var renderedParts = snake.Body.filter((_, i) => shouldRenderPart(snake, i));\n  return {\n    body: snake.Body.map((_, i) => formatSnakePart(snake, i)),\n    color: snake.Color,\n    _id: snake.ID,\n    name: snake.Name,\n    effectiveSpace: renderedParts.length,\n    health: snake.Health,\n    latency: snake.Latency,\n    error: snake.Error,\n    timing: snake.TimingMicros,\n    isDead: !!snake.Death,\n    death: formatDeath(snake.Death),\n    head: snake.HeadType && snake.HeadType.toLowerCase(),\n    tail: snake.TailType && snake.TailType.toLowerCase(),\n    headSvg: snake.HeadSvg,\n    tailSvg: snake.TailSvg,\n    squad: snake.Squad,\n    author: snake.Author,\n    shout: snake.Shout\n  };\n}\n\nfunction formatDeath(death) {\n  if (!death) {\n    return;\n  }\n  return {\n    cause: death.Cause,\n    turn: death.Turn || 0,\n    eliminatedBy: death.EliminatedBy\n  };\n}\n\nfunction shouldRenderPart(snake, partIndex) {\n  const headIndex = 0;\n  const tailIndex = snake.Body.length - 1;\n  const head = snake.Body[headIndex];\n  const tail = snake.Body[tailIndex];\n  const currPart = snake.Body[partIndex];\n\n  // always render head\n  if (partIndex === headIndex) {\n    return true;\n  }\n\n  // render tail if not covered by head\n  if (partIndex === tailIndex) {\n    return !(head.X === currPart.X && head.Y === currPart.Y);\n  }\n\n  // render middle part if it's in a different position than\n  // the next piece closer to head, and not in same spot as tail\n  const nextPart = snake.Body[partIndex - 1];\n  return (\n    !(tail.X === currPart.X && tail.Y === currPart.Y) &&\n    !(head.X === currPart.X && head.Y === currPart.Y) &&\n    !(nextPart && nextPart.X === currPart.X && nextPart.Y === currPart.Y)\n  );\n}\n\nfunction formatSnakePart(snake, partIndex) {\n  const part = snake.Body[partIndex];\n  const type = getType(snake, partIndex);\n  const { x, y } = formatPosition(part);\n  const direction = formatDirection(type, snake, part, partIndex);\n  const isOverlapped = !shouldRenderPart(snake, partIndex) ? true : undefined;\n\n  return {\n    direction,\n    type,\n    isOverlapped,\n    x,\n    y\n  };\n}\n\nfunction formatPositions(positions) {\n  if (positions) {\n    return positions.map(formatPosition);\n  }\n}\n\nfunction formatPosition(pos) {\n  return {\n    x: pos.X,\n    y: pos.Y\n  };\n}\n\nfunction formatDirection(type, snake, part, partIndex) {\n  let direction;\n  if (type === \"head\") {\n    direction = getDirection(snake.Body[1], snake.Body[0]);\n  } else {\n    // handle special case where parts overlap\n    var prevPart;\n    do {\n      prevPart = snake.Body[Math.max(partIndex - 1, 0)];\n      --partIndex;\n    } while (partIndex > 0 && prevPart.X === part.X && prevPart.Y === part.Y);\n\n    direction = getDirection(part, prevPart);\n  }\n\n  return direction;\n}\n\nfunction getDirection(a, b) {\n  if (a && b) {\n    // Handle cases where b is one move after a\n    if (a.X + 1 === b.X) {\n      return \"right\";\n    } else if (a.X - 1 === b.X) {\n      return \"left\";\n    } else if (a.Y + 1 === b.Y) {\n      return \"up\";\n    } else if (a.Y - 1 === b.Y) {\n      return \"down\";\n    }\n    // Handle wrapped cases (we can anchor against one part being on 0 axis)\n    if (a.X > b.X && b.X === 0) {\n      return \"right\";\n    } else if (a.X < b.X && a.X === 0) {\n      return \"left\";\n    } else if (a.Y > b.Y && b.Y === 0) {\n      return \"up\";\n    } else if (a.Y < b.Y && a.Y === 0) {\n      return \"down\";\n    }\n  }\n  return DEFAULT_DIRECTION;\n}\n\nfunction getType(snake, partIndex) {\n  if (partIndex === 0) {\n    return TYPE_HEAD;\n  }\n\n  if (partIndex === snake.Body.length - 1) {\n    return TYPE_TAIL;\n  }\n\n  return TYPE_BODY;\n}\n\n// This is a workaround for fields that are omitted when they have the default\n// value. ie: int fields that need to default to 0 rather than undefined.\nfunction cleanFrame(frame) {\n  frame.Turn = frame.Turn || 0;\n\n  for (const snake of frame.Snakes) {\n    for (const part of snake.Body) {\n      part.X = part.X || 0;\n      part.Y = part.Y || 0;\n    }\n  }\n\n  for (const food of frame.Food) {\n    food.X = food.X || 0;\n    food.Y = food.Y || 0;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}