{"ast":null,"code":"import cloneDeep from \"lodash.clonedeep\";\nconst DEFAULT_DIRECTION = \"right\";\nconst TYPE_HEAD = \"head\";\nconst TYPE_TAIL = \"tail\";\nconst TYPE_BODY = \"body\";\nexport function formatFrame(frame) {\n  cleanFrame(frame);\n  const snakes = formatSnakes(frame.Snakes);\n  return {\n    turn: frame.Turn,\n    snakes: snakes,\n    food: formatPositions(frame.Food),\n    hazards: formatPositions(frame.Hazards)\n  };\n}\nexport function sanitizeFrame(frame) {\n  // Copy without reference\n  const sanitizedFrame = cloneDeep(frame); // nullify some fields\n\n  for (const i in sanitizedFrame.snakes) {\n    const snake = sanitizedFrame.snakes[i];\n    snake.id = snake._id;\n    delete snake._id;\n    delete snake.headSvg;\n    delete snake.tailSvg;\n  }\n\n  return sanitizedFrame;\n}\n\nfunction formatSnakes(snakes) {\n  if (snakes) {\n    let newSnakes = snakes.map(formatSnake); // Populate eliminatedBy names\n\n    newSnakes.forEach(function (snake, index) {\n      if (snake.death && snake.death.eliminatedBy && snake.death.eliminatedBy.length > 0) {\n        for (const i in newSnakes) {\n          if (newSnakes[i]._id === snake.death.eliminatedBy) {\n            newSnakes[index].death.eliminatedBy = newSnakes[i].name;\n            break;\n          }\n        }\n      }\n    });\n    return newSnakes;\n  }\n}\n\nfunction formatSnake(snake) {\n  var renderedParts = snake.Body.filter((_, i) => shouldRenderPart(snake, i));\n  return {\n    body: snake.Body.map((_, i) => formatSnakePart(snake, i)),\n    color: snake.Color,\n    _id: snake.ID,\n    name: snake.Name,\n    effectiveSpace: renderedParts.length,\n    health: snake.Health,\n    latency: snake.Latency,\n    error: snake.Error,\n    timing: snake.TimingMicros,\n    isDead: !!snake.Death,\n    death: formatDeath(snake.Death),\n    head: snake.HeadType && snake.HeadType.toLowerCase(),\n    tail: snake.TailType && snake.TailType.toLowerCase(),\n    headSvg: snake.HeadSvg,\n    tailSvg: snake.TailSvg,\n    squad: snake.Squad,\n    author: snake.Author,\n    shout: snake.Shout\n  };\n}\n\nfunction formatDeath(death) {\n  if (!death) {\n    return;\n  }\n\n  return {\n    cause: death.Cause,\n    turn: death.Turn || 0,\n    eliminatedBy: death.EliminatedBy\n  };\n}\n\nfunction shouldRenderPart(snake, partIndex) {\n  const headIndex = 0;\n  const tailIndex = snake.Body.length - 1;\n  const head = snake.Body[headIndex];\n  const tail = snake.Body[tailIndex];\n  const currPart = snake.Body[partIndex]; // always render head\n\n  if (partIndex === headIndex) {\n    return true;\n  } // render tail if not covered by head\n\n\n  if (partIndex === tailIndex) {\n    return !(head.X === currPart.X && head.Y === currPart.Y);\n  } // render middle part if it's in a different position than\n  // the next piece closer to head, and not in same spot as tail\n\n\n  const nextPart = snake.Body[partIndex - 1];\n  return !(tail.X === currPart.X && tail.Y === currPart.Y) && !(head.X === currPart.X && head.Y === currPart.Y) && !(nextPart && nextPart.X === currPart.X && nextPart.Y === currPart.Y);\n}\n\nfunction formatSnakePart(snake, partIndex) {\n  const part = snake.Body[partIndex];\n  const type = getType(snake, partIndex);\n  const {\n    x,\n    y\n  } = formatPosition(part);\n  const direction = formatDirection(type, snake, part, partIndex);\n  const isOverlapped = !shouldRenderPart(snake, partIndex) ? true : undefined;\n  return {\n    direction,\n    type,\n    isOverlapped,\n    x,\n    y\n  };\n}\n\nfunction formatPositions(positions) {\n  if (positions) {\n    return positions.map(formatPosition);\n  }\n}\n\nfunction formatPosition(pos) {\n  return {\n    x: pos.X,\n    y: pos.Y\n  };\n}\n\nfunction formatDirection(type, snake, part, partIndex) {\n  let direction;\n\n  if (type === \"head\") {\n    direction = getDirection(snake.Body[1], snake.Body[0]);\n  } else {\n    // handle special case where parts overlap\n    var prevPart;\n\n    do {\n      prevPart = snake.Body[Math.max(partIndex - 1, 0)];\n      --partIndex;\n    } while (partIndex > 0 && prevPart.X === part.X && prevPart.Y === part.Y);\n\n    direction = getDirection(part, prevPart);\n  }\n\n  return direction;\n}\n\nfunction getDirection(a, b) {\n  if (a && b) {\n    // Handle cases where b is one move after a\n    if (a.X + 1 === b.X) {\n      return \"right\";\n    } else if (a.X - 1 === b.X) {\n      return \"left\";\n    } else if (a.Y + 1 === b.Y) {\n      return \"up\";\n    } else if (a.Y - 1 === b.Y) {\n      return \"down\";\n    } // Handle wrapped cases (we can anchor against one part being on 0 axis)\n\n\n    if (a.X > b.X && b.X === 0) {\n      return \"right\";\n    } else if (a.X < b.X && a.X === 0) {\n      return \"left\";\n    } else if (a.Y > b.Y && b.Y === 0) {\n      return \"up\";\n    } else if (a.Y < b.Y && a.Y === 0) {\n      return \"down\";\n    }\n  }\n\n  return DEFAULT_DIRECTION;\n}\n\nfunction getType(snake, partIndex) {\n  if (partIndex === 0) {\n    return TYPE_HEAD;\n  }\n\n  if (partIndex === snake.Body.length - 1) {\n    return TYPE_TAIL;\n  }\n\n  return TYPE_BODY;\n} // This is a workaround for fields that are omitted when they have the default\n// value. ie: int fields that need to default to 0 rather than undefined.\n\n\nfunction cleanFrame(frame) {\n  frame.Turn = frame.Turn || 0;\n\n  for (const snake of frame.Snakes) {\n    for (const part of snake.Body) {\n      part.X = part.X || 0;\n      part.Y = part.Y || 0;\n    }\n  }\n\n  for (const food of frame.Food) {\n    food.X = food.X || 0;\n    food.Y = food.Y || 0;\n  }\n}","map":{"version":3,"sources":["/home/y-yabust/CC/cc-replay/src/utils/game-state.js"],"names":["cloneDeep","DEFAULT_DIRECTION","TYPE_HEAD","TYPE_TAIL","TYPE_BODY","formatFrame","frame","cleanFrame","snakes","formatSnakes","Snakes","turn","Turn","food","formatPositions","Food","hazards","Hazards","sanitizeFrame","sanitizedFrame","i","snake","id","_id","headSvg","tailSvg","newSnakes","map","formatSnake","forEach","index","death","eliminatedBy","length","name","renderedParts","Body","filter","_","shouldRenderPart","body","formatSnakePart","color","Color","ID","Name","effectiveSpace","health","Health","latency","Latency","error","Error","timing","TimingMicros","isDead","Death","formatDeath","head","HeadType","toLowerCase","tail","TailType","HeadSvg","TailSvg","squad","Squad","author","Author","shout","Shout","cause","Cause","EliminatedBy","partIndex","headIndex","tailIndex","currPart","X","Y","nextPart","part","type","getType","x","y","formatPosition","direction","formatDirection","isOverlapped","undefined","positions","pos","getDirection","prevPart","Math","max","a","b"],"mappings":"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","sourcesContent":["import cloneDeep from \"lodash.clonedeep\";\n\nconst DEFAULT_DIRECTION = \"right\";\n\nconst TYPE_HEAD = \"head\";\nconst TYPE_TAIL = \"tail\";\nconst TYPE_BODY = \"body\";\n\nexport function formatFrame(frame) {\n  cleanFrame(frame);\n  const snakes = formatSnakes(frame.Snakes);\n  return {\n    turn: frame.Turn,\n    snakes: snakes,\n    food: formatPositions(frame.Food),\n    hazards: formatPositions(frame.Hazards)\n  };\n}\n\nexport function sanitizeFrame(frame) {\n  // Copy without reference\n  const sanitizedFrame = cloneDeep(frame);\n\n  // nullify some fields\n  for (const i in sanitizedFrame.snakes) {\n    const snake = sanitizedFrame.snakes[i];\n    snake.id = snake._id;\n    delete snake._id;\n\n    delete snake.headSvg;\n    delete snake.tailSvg;\n  }\n\n  return sanitizedFrame;\n}\n\nfunction formatSnakes(snakes) {\n  if (snakes) {\n    let newSnakes = snakes.map(formatSnake);\n\n    // Populate eliminatedBy names\n    newSnakes.forEach(function(snake, index) {\n      if (\n        snake.death &&\n        snake.death.eliminatedBy &&\n        snake.death.eliminatedBy.length > 0\n      ) {\n        for (const i in newSnakes) {\n          if (newSnakes[i]._id === snake.death.eliminatedBy) {\n            newSnakes[index].death.eliminatedBy = newSnakes[i].name;\n            break;\n          }\n        }\n      }\n    });\n    return newSnakes;\n  }\n}\n\nfunction formatSnake(snake) {\n  var renderedParts = snake.Body.filter((_, i) => shouldRenderPart(snake, i));\n  return {\n    body: snake.Body.map((_, i) => formatSnakePart(snake, i)),\n    color: snake.Color,\n    _id: snake.ID,\n    name: snake.Name,\n    effectiveSpace: renderedParts.length,\n    health: snake.Health,\n    latency: snake.Latency,\n    error: snake.Error,\n    timing: snake.TimingMicros,\n    isDead: !!snake.Death,\n    death: formatDeath(snake.Death),\n    head: snake.HeadType && snake.HeadType.toLowerCase(),\n    tail: snake.TailType && snake.TailType.toLowerCase(),\n    headSvg: snake.HeadSvg,\n    tailSvg: snake.TailSvg,\n    squad: snake.Squad,\n    author: snake.Author,\n    shout: snake.Shout\n  };\n}\n\nfunction formatDeath(death) {\n  if (!death) {\n    return;\n  }\n  return {\n    cause: death.Cause,\n    turn: death.Turn || 0,\n    eliminatedBy: death.EliminatedBy\n  };\n}\n\nfunction shouldRenderPart(snake, partIndex) {\n  const headIndex = 0;\n  const tailIndex = snake.Body.length - 1;\n  const head = snake.Body[headIndex];\n  const tail = snake.Body[tailIndex];\n  const currPart = snake.Body[partIndex];\n\n  // always render head\n  if (partIndex === headIndex) {\n    return true;\n  }\n\n  // render tail if not covered by head\n  if (partIndex === tailIndex) {\n    return !(head.X === currPart.X && head.Y === currPart.Y);\n  }\n\n  // render middle part if it's in a different position than\n  // the next piece closer to head, and not in same spot as tail\n  const nextPart = snake.Body[partIndex - 1];\n  return (\n    !(tail.X === currPart.X && tail.Y === currPart.Y) &&\n    !(head.X === currPart.X && head.Y === currPart.Y) &&\n    !(nextPart && nextPart.X === currPart.X && nextPart.Y === currPart.Y)\n  );\n}\n\nfunction formatSnakePart(snake, partIndex) {\n  const part = snake.Body[partIndex];\n  const type = getType(snake, partIndex);\n  const { x, y } = formatPosition(part);\n  const direction = formatDirection(type, snake, part, partIndex);\n  const isOverlapped = !shouldRenderPart(snake, partIndex) ? true : undefined;\n\n  return {\n    direction,\n    type,\n    isOverlapped,\n    x,\n    y\n  };\n}\n\nfunction formatPositions(positions) {\n  if (positions) {\n    return positions.map(formatPosition);\n  }\n}\n\nfunction formatPosition(pos) {\n  return {\n    x: pos.X,\n    y: pos.Y\n  };\n}\n\nfunction formatDirection(type, snake, part, partIndex) {\n  let direction;\n  if (type === \"head\") {\n    direction = getDirection(snake.Body[1], snake.Body[0]);\n  } else {\n    // handle special case where parts overlap\n    var prevPart;\n    do {\n      prevPart = snake.Body[Math.max(partIndex - 1, 0)];\n      --partIndex;\n    } while (partIndex > 0 && prevPart.X === part.X && prevPart.Y === part.Y);\n\n    direction = getDirection(part, prevPart);\n  }\n\n  return direction;\n}\n\nfunction getDirection(a, b) {\n  if (a && b) {\n    // Handle cases where b is one move after a\n    if (a.X + 1 === b.X) {\n      return \"right\";\n    } else if (a.X - 1 === b.X) {\n      return \"left\";\n    } else if (a.Y + 1 === b.Y) {\n      return \"up\";\n    } else if (a.Y - 1 === b.Y) {\n      return \"down\";\n    }\n    // Handle wrapped cases (we can anchor against one part being on 0 axis)\n    if (a.X > b.X && b.X === 0) {\n      return \"right\";\n    } else if (a.X < b.X && a.X === 0) {\n      return \"left\";\n    } else if (a.Y > b.Y && b.Y === 0) {\n      return \"up\";\n    } else if (a.Y < b.Y && a.Y === 0) {\n      return \"down\";\n    }\n  }\n  return DEFAULT_DIRECTION;\n}\n\nfunction getType(snake, partIndex) {\n  if (partIndex === 0) {\n    return TYPE_HEAD;\n  }\n\n  if (partIndex === snake.Body.length - 1) {\n    return TYPE_TAIL;\n  }\n\n  return TYPE_BODY;\n}\n\n// This is a workaround for fields that are omitted when they have the default\n// value. ie: int fields that need to default to 0 rather than undefined.\nfunction cleanFrame(frame) {\n  frame.Turn = frame.Turn || 0;\n\n  for (const snake of frame.Snakes) {\n    for (const part of snake.Body) {\n      part.X = part.X || 0;\n      part.Y = part.Y || 0;\n    }\n  }\n\n  for (const food of frame.Food) {\n    food.X = food.X || 0;\n    food.Y = food.Y || 0;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}