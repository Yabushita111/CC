{"ast":null,"code":"var _jsxFileName = \"/home/yabust/CC/board/src/components/grid.jsx\";\nimport React from \"react\";\nimport { colors, themes } from \"../theme\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst HIGHLIGHT_DIM = 0.15;\nconst DEAD_OPACITY = 0.1;\nconst OVERLAP_OPACITY = 0.3;\nconst SNAKE_ON_SNAKE_OPACITY = 0.8;\nconst FULL_OPACITY = 1.0;\nconst CELL_SIZE = 20;\nconst CELL_SPACING = 4;\nconst FOOD_SIZE = (CELL_SIZE / 3.25).toFixed(2);\nconst END_OVERLAP = 0.1;\nconst DIRECTIONS_CW = [\"up\", \"right\", \"down\", \"left\"]; // let GRID_COLUMNS = 0;  Unused for now.\n\nlet GRID_ROWS = 0;\n\nfunction toGridSpaceX(slot) {\n  return (CELL_SIZE + CELL_SPACING) * slot + CELL_SPACING;\n}\n\nfunction toGridSpaceY(slot) {\n  // Y-Axis in board space is inverted, positive goes up\n  return (CELL_SIZE + CELL_SPACING) * (GRID_ROWS - 1 - slot) + CELL_SPACING;\n}\n\nfunction getPartWidth(part) {\n  const extraWidth = part.direction === \"left\" || part.direction === \"right\" ? 2 * CELL_SPACING : 0;\n  return CELL_SIZE + extraWidth;\n}\n\nfunction getPartHeight(part) {\n  const extraHeight = part.direction === \"up\" || part.direction === \"down\" ? 2 * CELL_SPACING : 0;\n  return CELL_SIZE + extraHeight;\n}\n\nfunction getPartXOffset(part) {\n  const xBias = part.direction === \"left\" || part.direction === \"right\" ? -CELL_SPACING : 0;\n  return toGridSpaceX(part.x) + xBias;\n}\n\nfunction getPartYOffset(part) {\n  const yBias = part.direction === \"up\" || part.direction === \"down\" ? -CELL_SPACING : 0;\n  return toGridSpaceY(part.y) + yBias;\n}\n\nfunction getCornerPartXOffset(part, type) {\n  return toGridSpaceX(part.x) - CELL_SPACING;\n}\n\nfunction getCornerPartYOffset(part, type) {\n  return toGridSpaceY(part.y) - CELL_SPACING;\n}\n\nfunction getTailXOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"left\":\n      return toGridSpaceX(part.x) - END_OVERLAP;\n\n    case \"right\":\n      return toGridSpaceX(part.x) + END_OVERLAP;\n\n    default:\n      return toGridSpaceX(part.x);\n  }\n}\n\nfunction getTailYOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"up\":\n      return toGridSpaceY(part.y) - END_OVERLAP;\n\n    case \"down\":\n      return toGridSpaceY(part.y) + END_OVERLAP;\n\n    default:\n      return toGridSpaceY(part.y);\n  }\n}\n\nfunction getHeadXOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"left\":\n      return toGridSpaceX(part.x) + END_OVERLAP;\n\n    case \"right\":\n      return toGridSpaceX(part.x) - END_OVERLAP;\n\n    default:\n      return toGridSpaceX(part.x);\n  }\n}\n\nfunction getHeadYOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"up\":\n      return toGridSpaceY(part.y) + END_OVERLAP;\n\n    case \"down\":\n      return toGridSpaceY(part.y) - END_OVERLAP;\n\n    default:\n      return toGridSpaceY(part.y);\n  }\n}\n\nfunction getHeadFillerXOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"left\":\n      return toGridSpaceX(part.x + 1) - CELL_SPACING - END_OVERLAP;\n\n    case \"right\":\n      return toGridSpaceX(part.x) - CELL_SPACING - END_OVERLAP;\n\n    default:\n      return toGridSpaceX(part.x);\n  }\n}\n\nfunction getHeadFillerYOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"up\":\n      return toGridSpaceY(part.y - 1) - CELL_SPACING - END_OVERLAP;\n\n    case \"down\":\n      return toGridSpaceY(part.y) - CELL_SPACING - END_OVERLAP;\n\n    default:\n      return toGridSpaceY(part.y);\n  }\n}\n\nfunction getTailFillerXOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"right\":\n      return toGridSpaceX(part.x + 1) - CELL_SPACING - END_OVERLAP;\n\n    case \"left\":\n      return toGridSpaceX(part.x) - CELL_SPACING - END_OVERLAP;\n\n    default:\n      return toGridSpaceX(part.x);\n  }\n}\n\nfunction getTailFillerYOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"down\":\n      return toGridSpaceY(part.y - 1) - CELL_SPACING - END_OVERLAP;\n\n    case \"up\":\n      return toGridSpaceY(part.y) - CELL_SPACING - END_OVERLAP;\n\n    default:\n      return toGridSpaceY(part.y);\n  }\n}\n\nfunction getFillerWidth(part) {\n  return part.direction === \"left\" || part.direction === \"right\" ? CELL_SPACING + 2 * END_OVERLAP : CELL_SIZE;\n}\n\nfunction getFillerHeight(part) {\n  return part.direction === \"left\" || part.direction === \"right\" ? CELL_SIZE : CELL_SPACING + 2 * END_OVERLAP;\n}\n\nfunction getOpacity(snake, highlightedSnake) {\n  if (!snake.isDead) {\n    if (highlightedSnake) {\n      return snake._id === highlightedSnake ? 1 : HIGHLIGHT_DIM;\n    }\n  } else {\n    if (highlightedSnake) {\n      return snake._id === highlightedSnake ? 1 : 0;\n    }\n  }\n\n  return snake.isDead ? DEAD_OPACITY : 1;\n}\n\nfunction getPartOpacity(part) {\n  if (part.shadeForOverlap) {\n    return SNAKE_ON_SNAKE_OPACITY;\n  } else if (part.isOverlapped) {\n    return OVERLAP_OPACITY;\n  } else {\n    return FULL_OPACITY;\n  }\n}\n\nfunction getPartColor(snake, part) {\n  if (part.shadeForOverlap) {\n    return colors.overlapSnake;\n  } else {\n    return snake.color;\n  }\n}\n\nfunction range(size) {\n  const result = [];\n\n  for (let i = 0; i < size; i++) {\n    result.push(i);\n  }\n\n  return result;\n}\n\nfunction sortAliveSnakesOnTop(snakes, highlightedSnake) {\n  return snakes.concat().sort((a, b) => {\n    let aOrder = a.isDead ? 0 : 1;\n    let bOrder = b.isDead ? 0 : 1; // always put the highlighted snake up top\n\n    if (a._id === highlightedSnake) aOrder = 2;\n    if (b._id === highlightedSnake) bOrder = 2;\n    return aOrder - bOrder;\n  });\n}\n\nfunction getHeadTransform(direction, viewBox) {\n  const halfX = viewBox.width / 2;\n  const halfY = viewBox.height / 2;\n\n  switch (direction) {\n    case \"left\":\n      return `scale(-1,1) translate(-100, 0)`;\n\n    case \"up\":\n      return `rotate(-90 ${halfX} ${halfY})`;\n\n    case \"down\":\n      return `rotate(90 ${halfX} ${halfY})`;\n\n    default:\n      return \"\";\n  }\n}\n\nfunction getTailTransform(direction, viewBox) {\n  const halfX = viewBox.width / 2;\n  const halfY = viewBox.height / 2;\n\n  switch (direction) {\n    case \"right\":\n      return `scale(-1,1) translate(-100,0)`;\n\n    case \"down\":\n      return `scale(-1,1) translate(-100,0) rotate(-90 ${halfX} ${halfY})`;\n\n    case \"up\":\n      return `scale(-1,1) translate(-100,0) rotate(90 ${halfX} ${halfY})`;\n\n    default:\n      return \"\";\n  }\n}\n\nfunction areAdjacentDirections(d1, d2) {\n  // Check if the directions are adjacent in the circular directions array\n  // Otherwise they are the same or opposite directions\n  return Math.abs(DIRECTIONS_CW.indexOf(d1) - DIRECTIONS_CW.indexOf(d2)) % 2 === 1;\n}\n\nfunction checkIfCornerPart(snake, partIndex) {\n  // If head or tail of the snake, then false\n  if (partIndex === 0 || partIndex === snake.body.length - 1) return false;\n  const behind = snake.body[partIndex + 1];\n  const current = snake.body[partIndex]; // Return false if the behind part has the same position as the current.\n  // Relevant for when the snake initially spawns.\n\n  if (behind.x === current.x && behind.y === current.y) return false; // Check if the directions are adjacent in the circular directions array\n  // Otherwise they are the same or opposite directions and should be rendered with a straight part\n\n  return areAdjacentDirections(current.direction, behind.direction);\n}\n\nfunction determineCornerType(snake, partIndex) {\n  // If head or tail of the snake, then false\n  if (partIndex === 0 || partIndex === snake.body.length - 1) return false;\n  const behind = snake.body[partIndex + 1];\n  const current = snake.body[partIndex];\n  return `${current.direction} ${behind.direction}`;\n}\n\nfunction isOverlappedByTail(snake, part) {\n  const head = snake.body[snake.body.length - 1];\n  return part.isOverlapped && head.x === part.x && head.y === part.y;\n}\n\nclass Grid extends React.Component {\n  renderPart(snake, snakeIndex, part, partIndex) {\n    if (isOverlappedByTail(snake, part)) return;\n\n    switch (part.type) {\n      case \"head\":\n        return this.renderHeadPart(snake, snakeIndex, part);\n\n      case \"tail\":\n        return this.renderTailPart(snake, snakeIndex, part);\n\n      default:\n        if (checkIfCornerPart(snake, partIndex)) {\n          return this.renderCornerPart(snake, snakeIndex, part, partIndex);\n        } else {\n          return this.renderMiddlePart(snake, snakeIndex, part, partIndex);\n        }\n\n    }\n  }\n\n  renderHeadPart(snake, snakeIndex, part) {\n    const x = getHeadXOffset(part);\n    const y = getHeadYOffset(part);\n    const box = snake.headSvg.viewBox.baseVal;\n    const transform = getHeadTransform(part.direction, box);\n    const viewBoxStr = `${box.x} ${box.y} ${box.width} ${box.height}`;\n    let color = getPartColor(snake, part);\n    let opacity = getPartOpacity(part);\n    return /*#__PURE__*/_jsxDEV(\"g\", {\n      children: [/*#__PURE__*/_jsxDEV(\"svg\", {\n        viewBox: viewBoxStr,\n        x: x,\n        y: y,\n        width: CELL_SIZE,\n        height: CELL_SIZE,\n        fill: color,\n        opacity: opacity,\n        shapeRendering: \"auto\",\n        children: /*#__PURE__*/_jsxDEV(\"g\", {\n          transform: transform,\n          dangerouslySetInnerHTML: {\n            __html: snake.headSvg.innerHTML\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 331,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 321,\n        columnNumber: 9\n      }, this), snake.effectiveSpace > 1 &&\n      /*#__PURE__*/\n      // only add filler if the snake is effectively longer than one tile\n      _jsxDEV(\"rect\", {\n        x: getHeadFillerXOffset(part),\n        y: getHeadFillerYOffset(part),\n        width: getFillerWidth(part),\n        height: getFillerHeight(part),\n        fill: color,\n        opacity: opacity,\n        shapeRendering: \"auto\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 11\n      }, this)]\n    }, \"part\" + snakeIndex + \",head\", true, {\n      fileName: _jsxFileName,\n      lineNumber: 320,\n      columnNumber: 7\n    }, this);\n  }\n\n  renderMiddlePart(snake, snakeIndex, part, partIndex) {\n    let color = getPartColor(snake, part);\n    let opacity = getPartOpacity(part);\n    return /*#__PURE__*/_jsxDEV(\"rect\", {\n      x: getPartXOffset(part),\n      y: getPartYOffset(part),\n      width: getPartWidth(part),\n      height: getPartHeight(part),\n      fill: color,\n      opacity: opacity,\n      shapeRendering: \"auto\"\n    }, `part${snakeIndex},${part.x},${part.y}`, false, {\n      fileName: _jsxFileName,\n      lineNumber: 357,\n      columnNumber: 7\n    }, this);\n  }\n\n  renderCornerPart(snake, snakeIndex, part, partIndex) {\n    let viewBox, transform;\n    let path = \"M0,20 h60 a60,60 0 0 1 60,60 v60 h-100 v-20 h-20 z\";\n    let color = getPartColor(snake, part);\n    let opacity = getPartOpacity(part);\n    viewBox = \"0 0 140 140\";\n    const cornerType = determineCornerType(snake, partIndex);\n\n    switch (cornerType) {\n      case \"down left\":\n      case \"right up\":\n        transform = \"rotate(270, 70, 70)\";\n        break;\n\n      case \"left down\":\n      case \"up right\":\n        transform = \"rotate(90, 70, 70)\";\n        break;\n\n      case \"left up\":\n      case \"down right\":\n        break;\n\n      case \"right down\":\n      case \"up left\":\n        transform = \"rotate(180, 70, 70)\";\n        break;\n\n      default:\n        break;\n    }\n\n    return /*#__PURE__*/_jsxDEV(\"svg\", {\n      x: getCornerPartXOffset(part, cornerType),\n      y: getCornerPartYOffset(part, cornerType),\n      width: CELL_SIZE + 2 * CELL_SPACING,\n      height: CELL_SIZE + 2 * CELL_SPACING,\n      fill: color,\n      opacity: opacity,\n      viewBox: viewBox,\n      shapeRendering: \"auto\",\n      children: /*#__PURE__*/_jsxDEV(\"path\", {\n        d: path,\n        transform: transform\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 411,\n        columnNumber: 9\n      }, this)\n    }, `part${snakeIndex},${part.x},${part.y}`, false, {\n      fileName: _jsxFileName,\n      lineNumber: 400,\n      columnNumber: 7\n    }, this);\n  }\n\n  renderTailPart(snake, snakeIndex, part) {\n    const x = getTailXOffset(part);\n    const y = getTailYOffset(part);\n    const box = snake.tailSvg.viewBox.baseVal;\n    const transform = getTailTransform(part.direction, box);\n    const viewBoxStr = `${box.x} ${box.y} ${box.width} ${box.height}`;\n    let color = getPartColor(snake, part);\n    let opacity = getPartOpacity(part);\n    return /*#__PURE__*/_jsxDEV(\"g\", {\n      children: [/*#__PURE__*/_jsxDEV(\"svg\", {\n        viewBox: viewBoxStr,\n        x: x,\n        y: y,\n        width: CELL_SIZE,\n        height: CELL_SIZE,\n        fill: color,\n        opacity: opacity,\n        shapeRendering: \"auto\",\n        children: /*#__PURE__*/_jsxDEV(\"g\", {\n          transform: transform,\n          dangerouslySetInnerHTML: {\n            __html: snake.tailSvg.innerHTML\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 437,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 427,\n        columnNumber: 9\n      }, this), snake.effectiveSpace > 1 &&\n      /*#__PURE__*/\n      // only add filler if the snake is effectively longer than one tile\n      _jsxDEV(\"rect\", {\n        x: getTailFillerXOffset(part),\n        y: getTailFillerYOffset(part),\n        width: getFillerWidth(part),\n        height: getFillerHeight(part),\n        fill: color,\n        opacity: opacity,\n        shapeRendering: \"auto\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 444,\n        columnNumber: 11\n      }, this)]\n    }, \"part\" + snakeIndex + \",tail\", true, {\n      fileName: _jsxFileName,\n      lineNumber: 426,\n      columnNumber: 7\n    }, this);\n  }\n\n  renderLabel(row, col, label) {\n    return /*#__PURE__*/_jsxDEV(\"foreignObject\", {\n      x: toGridSpaceX(col),\n      y: toGridSpaceY(row),\n      width: CELL_SIZE,\n      height: CELL_SIZE,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          width: \"100%\",\n          height: \"100%\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          opacity: 0.5\n        },\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontSize: \"80%\"\n          },\n          children: label\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 477,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 467,\n        columnNumber: 9\n      }, this)\n    }, \"label\" + row + col, false, {\n      fileName: _jsxFileName,\n      lineNumber: 460,\n      columnNumber: 7\n    }, this);\n  }\n\n  renderLabels() {\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [range(this.props.rows).map((_, row) => this.renderLabel(row, -1, row)), range(this.props.columns).map((_, col) => this.renderLabel(-1, col, col))]\n    }, void 0, true);\n  }\n\n  renderGrid() {\n    // GRID_COLUMNS = this.props.columns;\n    GRID_ROWS = this.props.rows;\n    const unsortedSnakes = this.props.snakes || [];\n    const food = this.props.food || [];\n    const hazards = this.props.hazards || []; // Make alive snakes render on top of dead snakes\n\n    const sortedSnakes = sortAliveSnakesOnTop(unsortedSnakes, this.props.highlightedSnake);\n\n    if (!this.props.highlightedSnake) {\n      // track all of the grid cells that will have a snake part drawn in them.  Successive snake parts\n      // drawn in the same cell need to be flagged so they render differently and layer properly\n      let gridCellsWithSnakeParts = Array(this.props.rows);\n\n      for (let i = 0; i < gridCellsWithSnakeParts.length; i++) {\n        gridCellsWithSnakeParts[i] = Array(this.props.columns);\n\n        for (let j = 0; j < this.props.columns; j++) {\n          gridCellsWithSnakeParts[i][j] = false;\n        }\n      } // Go through each snake, in the order they will be drawn and mark the cells they will occupy.\n      // flag parts that would be drawn in cells that are already claimed\n\n\n      for (let i = 0; i < sortedSnakes.length; i++) {\n        let snake = sortedSnakes[i];\n\n        if (!snake.isDead) {\n          for (let x = 0; x < snake.body.length; x++) {\n            let part = snake.body[x];\n\n            if (!isOverlappedByTail(snake, part)) {\n              if (gridCellsWithSnakeParts[part.y][part.x]) {\n                part.shadeForOverlap = true;\n              } else {\n                gridCellsWithSnakeParts[part.y][part.x] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    const viewBoxWidth = (CELL_SIZE + CELL_SPACING) * this.props.columns + CELL_SPACING;\n    const viewBoxHeight = (CELL_SIZE + CELL_SPACING) * this.props.rows + CELL_SPACING;\n    const hazardOpacity = parseFloat(colors.hazardOpacity);\n    const overflow = this.props.showCoordinateLabels ? \"visible\" : \"hidden\";\n    return /*#__PURE__*/_jsxDEV(\"svg\", {\n      className: \"grid\",\n      width: this.props.maxWidth,\n      height: this.props.maxHeight,\n      x: this.props.x,\n      y: this.props.y,\n      viewBox: `0 0 ${viewBoxWidth} ${viewBoxHeight}`,\n      overflow: overflow,\n      children: [this.props.showCoordinateLabels && this.renderLabels(), range(this.props.rows).map((_, row) => range(this.props.columns).map((_, col) => /*#__PURE__*/_jsxDEV(\"rect\", {\n        x: toGridSpaceX(col),\n        y: toGridSpaceY(row),\n        width: CELL_SIZE,\n        height: CELL_SIZE,\n        fill: this.props.theme === themes.dark ? colors.gridCellBackgroundDark : colors.gridCellBackground,\n        shapeRendering: \"auto\"\n      }, \"cell\" + row + \",\" + col, false, {\n        fileName: _jsxFileName,\n        lineNumber: 561,\n        columnNumber: 13\n      }, this))), sortedSnakes.map((snake, snakeIndex) => {\n        return /*#__PURE__*/_jsxDEV(\"g\", {\n          className: \"snake\",\n          opacity: getOpacity(snake, this.props.highlightedSnake),\n          children: [...snake.body].reverse().map((part, partIndex) => this.renderPart(snake, snakeIndex, part, snake.body.length - partIndex - 1, this.props.highlightedSnake))\n        }, `snake${snakeIndex}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 578,\n          columnNumber: 13\n        }, this);\n      }), hazards.map((o, hazardIndex) => /*#__PURE__*/_jsxDEV(\"rect\", {\n        x: toGridSpaceX(o.x),\n        y: toGridSpaceY(o.y),\n        width: CELL_SIZE,\n        height: CELL_SIZE,\n        fill: colors.hazard,\n        fillOpacity: hazardOpacity,\n        shapeRendering: \"auto\"\n      }, \"hazard\" + hazardIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 598,\n        columnNumber: 11\n      }, this)), food.map((f, foodIndex) => {\n        if (this.props.foodImage) {\n          return /*#__PURE__*/_jsxDEV(\"image\", {\n            x: toGridSpaceX(f.x),\n            y: toGridSpaceY(f.y),\n            width: CELL_SIZE,\n            height: CELL_SIZE,\n            href: this.props.foodImage\n          }, \"food\" + foodIndex, false, {\n            fileName: _jsxFileName,\n            lineNumber: 612,\n            columnNumber: 15\n          }, this);\n        } else {\n          return /*#__PURE__*/_jsxDEV(\"circle\", {\n            className: \"food\",\n            cx: toGridSpaceX(f.x) + CELL_SIZE / 2,\n            cy: toGridSpaceY(f.y) + CELL_SIZE / 2,\n            r: FOOD_SIZE,\n            fill: colors.food,\n            shapeRendering: \"optimizeQuality\"\n          }, \"food\" + foodIndex, false, {\n            fileName: _jsxFileName,\n            lineNumber: 623,\n            columnNumber: 15\n          }, this);\n        }\n      })]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 549,\n      columnNumber: 7\n    }, this);\n  }\n\n  render() {\n    if (this.props.snakes) {\n      return this.renderGrid();\n    } else {\n      return;\n    }\n  }\n\n}\n\nexport default Grid;","map":{"version":3,"sources":["/home/yabust/CC/board/src/components/grid.jsx"],"names":["React","colors","themes","HIGHLIGHT_DIM","DEAD_OPACITY","OVERLAP_OPACITY","SNAKE_ON_SNAKE_OPACITY","FULL_OPACITY","CELL_SIZE","CELL_SPACING","FOOD_SIZE","toFixed","END_OVERLAP","DIRECTIONS_CW","GRID_ROWS","toGridSpaceX","slot","toGridSpaceY","getPartWidth","part","extraWidth","direction","getPartHeight","extraHeight","getPartXOffset","xBias","x","getPartYOffset","yBias","y","getCornerPartXOffset","type","getCornerPartYOffset","getTailXOffset","getTailYOffset","getHeadXOffset","getHeadYOffset","getHeadFillerXOffset","getHeadFillerYOffset","getTailFillerXOffset","getTailFillerYOffset","getFillerWidth","getFillerHeight","getOpacity","snake","highlightedSnake","isDead","_id","getPartOpacity","shadeForOverlap","isOverlapped","getPartColor","overlapSnake","color","range","size","result","i","push","sortAliveSnakesOnTop","snakes","concat","sort","a","b","aOrder","bOrder","getHeadTransform","viewBox","halfX","width","halfY","height","getTailTransform","areAdjacentDirections","d1","d2","Math","abs","indexOf","checkIfCornerPart","partIndex","body","length","behind","current","determineCornerType","isOverlappedByTail","head","Grid","Component","renderPart","snakeIndex","renderHeadPart","renderTailPart","renderCornerPart","renderMiddlePart","box","headSvg","baseVal","transform","viewBoxStr","opacity","__html","innerHTML","effectiveSpace","path","cornerType","tailSvg","renderLabel","row","col","label","display","alignItems","justifyContent","fontSize","renderLabels","props","rows","map","_","columns","renderGrid","unsortedSnakes","food","hazards","sortedSnakes","gridCellsWithSnakeParts","Array","j","viewBoxWidth","viewBoxHeight","hazardOpacity","parseFloat","overflow","showCoordinateLabels","maxWidth","maxHeight","theme","dark","gridCellBackgroundDark","gridCellBackground","reverse","o","hazardIndex","hazard","f","foodIndex","foodImage","render"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { colors, themes } from \"../theme\";\n\nconst HIGHLIGHT_DIM = 0.15;\nconst DEAD_OPACITY = 0.1;\nconst OVERLAP_OPACITY = 0.3;\nconst SNAKE_ON_SNAKE_OPACITY = 0.8;\nconst FULL_OPACITY = 1.0;\n\nconst CELL_SIZE = 20;\nconst CELL_SPACING = 4;\nconst FOOD_SIZE = (CELL_SIZE / 3.25).toFixed(2);\nconst END_OVERLAP = 0.1;\n\nconst DIRECTIONS_CW = [\"up\", \"right\", \"down\", \"left\"];\n\n// let GRID_COLUMNS = 0;  Unused for now.\nlet GRID_ROWS = 0;\n\nfunction toGridSpaceX(slot) {\n  return (CELL_SIZE + CELL_SPACING) * slot + CELL_SPACING;\n}\n\nfunction toGridSpaceY(slot) {\n  // Y-Axis in board space is inverted, positive goes up\n  return (CELL_SIZE + CELL_SPACING) * (GRID_ROWS - 1 - slot) + CELL_SPACING;\n}\n\nfunction getPartWidth(part) {\n  const extraWidth =\n    part.direction === \"left\" || part.direction === \"right\"\n      ? 2 * CELL_SPACING\n      : 0;\n  return CELL_SIZE + extraWidth;\n}\n\nfunction getPartHeight(part) {\n  const extraHeight =\n    part.direction === \"up\" || part.direction === \"down\" ? 2 * CELL_SPACING : 0;\n  return CELL_SIZE + extraHeight;\n}\n\nfunction getPartXOffset(part) {\n  const xBias =\n    part.direction === \"left\" || part.direction === \"right\" ? -CELL_SPACING : 0;\n  return toGridSpaceX(part.x) + xBias;\n}\n\nfunction getPartYOffset(part) {\n  const yBias =\n    part.direction === \"up\" || part.direction === \"down\" ? -CELL_SPACING : 0;\n  return toGridSpaceY(part.y) + yBias;\n}\n\nfunction getCornerPartXOffset(part, type) {\n  return toGridSpaceX(part.x) - CELL_SPACING;\n}\n\nfunction getCornerPartYOffset(part, type) {\n  return toGridSpaceY(part.y) - CELL_SPACING;\n}\n\nfunction getTailXOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"left\":\n      return toGridSpaceX(part.x) - END_OVERLAP;\n    case \"right\":\n      return toGridSpaceX(part.x) + END_OVERLAP;\n    default:\n      return toGridSpaceX(part.x);\n  }\n}\n\nfunction getTailYOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"up\":\n      return toGridSpaceY(part.y) - END_OVERLAP;\n    case \"down\":\n      return toGridSpaceY(part.y) + END_OVERLAP;\n    default:\n      return toGridSpaceY(part.y);\n  }\n}\n\nfunction getHeadXOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"left\":\n      return toGridSpaceX(part.x) + END_OVERLAP;\n    case \"right\":\n      return toGridSpaceX(part.x) - END_OVERLAP;\n    default:\n      return toGridSpaceX(part.x);\n  }\n}\n\nfunction getHeadYOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"up\":\n      return toGridSpaceY(part.y) + END_OVERLAP;\n    case \"down\":\n      return toGridSpaceY(part.y) - END_OVERLAP;\n    default:\n      return toGridSpaceY(part.y);\n  }\n}\n\nfunction getHeadFillerXOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"left\":\n      return toGridSpaceX(part.x + 1) - CELL_SPACING - END_OVERLAP;\n    case \"right\":\n      return toGridSpaceX(part.x) - CELL_SPACING - END_OVERLAP;\n    default:\n      return toGridSpaceX(part.x);\n  }\n}\n\nfunction getHeadFillerYOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"up\":\n      return toGridSpaceY(part.y - 1) - CELL_SPACING - END_OVERLAP;\n    case \"down\":\n      return toGridSpaceY(part.y) - CELL_SPACING - END_OVERLAP;\n    default:\n      return toGridSpaceY(part.y);\n  }\n}\n\nfunction getTailFillerXOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"right\":\n      return toGridSpaceX(part.x + 1) - CELL_SPACING - END_OVERLAP;\n    case \"left\":\n      return toGridSpaceX(part.x) - CELL_SPACING - END_OVERLAP;\n    default:\n      return toGridSpaceX(part.x);\n  }\n}\n\nfunction getTailFillerYOffset(part) {\n  // apply slight offset to avoid ugly white line in between parts (works most of the time)\n  switch (part.direction) {\n    case \"down\":\n      return toGridSpaceY(part.y - 1) - CELL_SPACING - END_OVERLAP;\n    case \"up\":\n      return toGridSpaceY(part.y) - CELL_SPACING - END_OVERLAP;\n    default:\n      return toGridSpaceY(part.y);\n  }\n}\n\nfunction getFillerWidth(part) {\n  return part.direction === \"left\" || part.direction === \"right\"\n    ? CELL_SPACING + 2 * END_OVERLAP\n    : CELL_SIZE;\n}\n\nfunction getFillerHeight(part) {\n  return part.direction === \"left\" || part.direction === \"right\"\n    ? CELL_SIZE\n    : CELL_SPACING + 2 * END_OVERLAP;\n}\n\nfunction getOpacity(snake, highlightedSnake) {\n  if (!snake.isDead) {\n    if (highlightedSnake) {\n      return snake._id === highlightedSnake ? 1 : HIGHLIGHT_DIM;\n    }\n  } else {\n    if (highlightedSnake) {\n      return snake._id === highlightedSnake ? 1 : 0;\n    }\n  }\n\n  return snake.isDead ? DEAD_OPACITY : 1;\n}\n\nfunction getPartOpacity(part) {\n  if (part.shadeForOverlap) {\n    return SNAKE_ON_SNAKE_OPACITY;\n  } else if (part.isOverlapped) {\n    return OVERLAP_OPACITY;\n  } else {\n    return FULL_OPACITY;\n  }\n}\n\nfunction getPartColor(snake, part) {\n  if (part.shadeForOverlap) {\n    return colors.overlapSnake;\n  } else {\n    return snake.color;\n  }\n}\n\nfunction range(size) {\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction sortAliveSnakesOnTop(snakes, highlightedSnake) {\n  return snakes.concat().sort((a, b) => {\n    let aOrder = a.isDead ? 0 : 1;\n    let bOrder = b.isDead ? 0 : 1;\n\n    // always put the highlighted snake up top\n    if (a._id === highlightedSnake) aOrder = 2;\n    if (b._id === highlightedSnake) bOrder = 2;\n\n    return aOrder - bOrder;\n  });\n}\n\nfunction getHeadTransform(direction, viewBox) {\n  const halfX = viewBox.width / 2;\n  const halfY = viewBox.height / 2;\n  switch (direction) {\n    case \"left\":\n      return `scale(-1,1) translate(-100, 0)`;\n    case \"up\":\n      return `rotate(-90 ${halfX} ${halfY})`;\n    case \"down\":\n      return `rotate(90 ${halfX} ${halfY})`;\n    default:\n      return \"\";\n  }\n}\n\nfunction getTailTransform(direction, viewBox) {\n  const halfX = viewBox.width / 2;\n  const halfY = viewBox.height / 2;\n  switch (direction) {\n    case \"right\":\n      return `scale(-1,1) translate(-100,0)`;\n    case \"down\":\n      return `scale(-1,1) translate(-100,0) rotate(-90 ${halfX} ${halfY})`;\n    case \"up\":\n      return `scale(-1,1) translate(-100,0) rotate(90 ${halfX} ${halfY})`;\n    default:\n      return \"\";\n  }\n}\n\nfunction areAdjacentDirections(d1, d2) {\n  // Check if the directions are adjacent in the circular directions array\n  // Otherwise they are the same or opposite directions\n  return (\n    Math.abs(DIRECTIONS_CW.indexOf(d1) - DIRECTIONS_CW.indexOf(d2)) % 2 === 1\n  );\n}\n\nfunction checkIfCornerPart(snake, partIndex) {\n  // If head or tail of the snake, then false\n  if (partIndex === 0 || partIndex === snake.body.length - 1) return false;\n\n  const behind = snake.body[partIndex + 1];\n  const current = snake.body[partIndex];\n\n  // Return false if the behind part has the same position as the current.\n  // Relevant for when the snake initially spawns.\n  if (behind.x === current.x && behind.y === current.y) return false;\n\n  // Check if the directions are adjacent in the circular directions array\n  // Otherwise they are the same or opposite directions and should be rendered with a straight part\n  return areAdjacentDirections(current.direction, behind.direction);\n}\n\nfunction determineCornerType(snake, partIndex) {\n  // If head or tail of the snake, then false\n  if (partIndex === 0 || partIndex === snake.body.length - 1) return false;\n\n  const behind = snake.body[partIndex + 1];\n  const current = snake.body[partIndex];\n\n  return `${current.direction} ${behind.direction}`;\n}\n\nfunction isOverlappedByTail(snake, part) {\n  const head = snake.body[snake.body.length - 1];\n  return part.isOverlapped && head.x === part.x && head.y === part.y;\n}\n\nclass Grid extends React.Component {\n  renderPart(snake, snakeIndex, part, partIndex) {\n    if (isOverlappedByTail(snake, part)) return;\n    switch (part.type) {\n      case \"head\":\n        return this.renderHeadPart(snake, snakeIndex, part);\n      case \"tail\":\n        return this.renderTailPart(snake, snakeIndex, part);\n      default:\n        if (checkIfCornerPart(snake, partIndex)) {\n          return this.renderCornerPart(snake, snakeIndex, part, partIndex);\n        } else {\n          return this.renderMiddlePart(snake, snakeIndex, part, partIndex);\n        }\n    }\n  }\n\n  renderHeadPart(snake, snakeIndex, part) {\n    const x = getHeadXOffset(part);\n    const y = getHeadYOffset(part);\n    const box = snake.headSvg.viewBox.baseVal;\n    const transform = getHeadTransform(part.direction, box);\n    const viewBoxStr = `${box.x} ${box.y} ${box.width} ${box.height}`;\n    let color = getPartColor(snake, part);\n    let opacity = getPartOpacity(part);\n\n    return (\n      <g key={\"part\" + snakeIndex + \",head\"}>\n        <svg\n          viewBox={viewBoxStr}\n          x={x}\n          y={y}\n          width={CELL_SIZE}\n          height={CELL_SIZE}\n          fill={color}\n          opacity={opacity}\n          shapeRendering=\"auto\"\n        >\n          <g\n            transform={transform}\n            dangerouslySetInnerHTML={{ __html: snake.headSvg.innerHTML }}\n          />\n        </svg>\n        {snake.effectiveSpace > 1 && (\n          // only add filler if the snake is effectively longer than one tile\n          <rect\n            x={getHeadFillerXOffset(part)}\n            y={getHeadFillerYOffset(part)}\n            width={getFillerWidth(part)}\n            height={getFillerHeight(part)}\n            fill={color}\n            opacity={opacity}\n            shapeRendering=\"auto\"\n          />\n        )}\n      </g>\n    );\n  }\n\n  renderMiddlePart(snake, snakeIndex, part, partIndex) {\n    let color = getPartColor(snake, part);\n    let opacity = getPartOpacity(part);\n\n    return (\n      <rect\n        key={`part${snakeIndex},${part.x},${part.y}`}\n        x={getPartXOffset(part)}\n        y={getPartYOffset(part)}\n        width={getPartWidth(part)}\n        height={getPartHeight(part)}\n        fill={color}\n        opacity={opacity}\n        shapeRendering=\"auto\"\n      />\n    );\n  }\n\n  renderCornerPart(snake, snakeIndex, part, partIndex) {\n    let viewBox, transform;\n    let path = \"M0,20 h60 a60,60 0 0 1 60,60 v60 h-100 v-20 h-20 z\";\n    let color = getPartColor(snake, part);\n    let opacity = getPartOpacity(part);\n\n    viewBox = \"0 0 140 140\";\n\n    const cornerType = determineCornerType(snake, partIndex);\n    switch (cornerType) {\n      case \"down left\":\n      case \"right up\":\n        transform = \"rotate(270, 70, 70)\";\n        break;\n      case \"left down\":\n      case \"up right\":\n        transform = \"rotate(90, 70, 70)\";\n        break;\n      case \"left up\":\n      case \"down right\":\n        break;\n      case \"right down\":\n      case \"up left\":\n        transform = \"rotate(180, 70, 70)\";\n        break;\n      default:\n        break;\n    }\n\n    return (\n      <svg\n        key={`part${snakeIndex},${part.x},${part.y}`}\n        x={getCornerPartXOffset(part, cornerType)}\n        y={getCornerPartYOffset(part, cornerType)}\n        width={CELL_SIZE + 2 * CELL_SPACING}\n        height={CELL_SIZE + 2 * CELL_SPACING}\n        fill={color}\n        opacity={opacity}\n        viewBox={viewBox}\n        shapeRendering=\"auto\"\n      >\n        <path d={path} transform={transform} />\n      </svg>\n    );\n  }\n\n  renderTailPart(snake, snakeIndex, part) {\n    const x = getTailXOffset(part);\n    const y = getTailYOffset(part);\n    const box = snake.tailSvg.viewBox.baseVal;\n    const transform = getTailTransform(part.direction, box);\n    const viewBoxStr = `${box.x} ${box.y} ${box.width} ${box.height}`;\n    let color = getPartColor(snake, part);\n    let opacity = getPartOpacity(part);\n\n    return (\n      <g key={\"part\" + snakeIndex + \",tail\"}>\n        <svg\n          viewBox={viewBoxStr}\n          x={x}\n          y={y}\n          width={CELL_SIZE}\n          height={CELL_SIZE}\n          fill={color}\n          opacity={opacity}\n          shapeRendering=\"auto\"\n        >\n          <g\n            transform={transform}\n            dangerouslySetInnerHTML={{ __html: snake.tailSvg.innerHTML }}\n          />\n        </svg>\n        {snake.effectiveSpace > 1 && (\n          // only add filler if the snake is effectively longer than one tile\n          <rect\n            x={getTailFillerXOffset(part)}\n            y={getTailFillerYOffset(part)}\n            width={getFillerWidth(part)}\n            height={getFillerHeight(part)}\n            fill={color}\n            opacity={opacity}\n            shapeRendering=\"auto\"\n          />\n        )}\n      </g>\n    );\n  }\n\n  renderLabel(row, col, label) {\n    return (\n      <foreignObject\n        key={\"label\" + row + col}\n        x={toGridSpaceX(col)}\n        y={toGridSpaceY(row)}\n        width={CELL_SIZE}\n        height={CELL_SIZE}\n      >\n        <div\n          style={{\n            width: \"100%\",\n            height: \"100%\",\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"center\",\n            opacity: 0.5\n          }}\n        >\n          <div style={{ fontSize: \"80%\" }}>{label}</div>\n        </div>\n      </foreignObject>\n    );\n  }\n\n  renderLabels() {\n    return (\n      <>\n        {range(this.props.rows).map((_, row) => this.renderLabel(row, -1, row))}\n\n        {range(this.props.columns).map((_, col) =>\n          this.renderLabel(-1, col, col)\n        )}\n      </>\n    );\n  }\n\n  renderGrid() {\n    // GRID_COLUMNS = this.props.columns;\n    GRID_ROWS = this.props.rows;\n\n    const unsortedSnakes = this.props.snakes || [];\n    const food = this.props.food || [];\n    const hazards = this.props.hazards || [];\n\n    // Make alive snakes render on top of dead snakes\n    const sortedSnakes = sortAliveSnakesOnTop(\n      unsortedSnakes,\n      this.props.highlightedSnake\n    );\n\n    if (!this.props.highlightedSnake) {\n      // track all of the grid cells that will have a snake part drawn in them.  Successive snake parts\n      // drawn in the same cell need to be flagged so they render differently and layer properly\n      let gridCellsWithSnakeParts = Array(this.props.rows);\n      for (let i = 0; i < gridCellsWithSnakeParts.length; i++) {\n        gridCellsWithSnakeParts[i] = Array(this.props.columns);\n        for (let j = 0; j < this.props.columns; j++) {\n          gridCellsWithSnakeParts[i][j] = false;\n        }\n      }\n\n      // Go through each snake, in the order they will be drawn and mark the cells they will occupy.\n      // flag parts that would be drawn in cells that are already claimed\n      for (let i = 0; i < sortedSnakes.length; i++) {\n        let snake = sortedSnakes[i];\n        if (!snake.isDead) {\n          for (let x = 0; x < snake.body.length; x++) {\n            let part = snake.body[x];\n            if (!isOverlappedByTail(snake, part)) {\n              if (gridCellsWithSnakeParts[part.y][part.x]) {\n                part.shadeForOverlap = true;\n              } else {\n                gridCellsWithSnakeParts[part.y][part.x] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    const viewBoxWidth =\n      (CELL_SIZE + CELL_SPACING) * this.props.columns + CELL_SPACING;\n    const viewBoxHeight =\n      (CELL_SIZE + CELL_SPACING) * this.props.rows + CELL_SPACING;\n\n    const hazardOpacity = parseFloat(colors.hazardOpacity);\n\n    const overflow = this.props.showCoordinateLabels ? \"visible\" : \"hidden\";\n\n    return (\n      <svg\n        className=\"grid\"\n        width={this.props.maxWidth}\n        height={this.props.maxHeight}\n        x={this.props.x}\n        y={this.props.y}\n        viewBox={`0 0 ${viewBoxWidth} ${viewBoxHeight}`}\n        overflow={overflow}\n      >\n        {this.props.showCoordinateLabels && this.renderLabels()}\n        {range(this.props.rows).map((_, row) =>\n          range(this.props.columns).map((_, col) => (\n            <rect\n              key={\"cell\" + row + \",\" + col}\n              x={toGridSpaceX(col)}\n              y={toGridSpaceY(row)}\n              width={CELL_SIZE}\n              height={CELL_SIZE}\n              fill={\n                this.props.theme === themes.dark\n                  ? colors.gridCellBackgroundDark\n                  : colors.gridCellBackground\n              }\n              shapeRendering=\"auto\"\n            />\n          ))\n        )}\n        {sortedSnakes.map((snake, snakeIndex) => {\n          return (\n            <g\n              key={`snake${snakeIndex}`}\n              className=\"snake\"\n              opacity={getOpacity(snake, this.props.highlightedSnake)}\n            >\n              {[...snake.body]\n                .reverse()\n                .map((part, partIndex) =>\n                  this.renderPart(\n                    snake,\n                    snakeIndex,\n                    part,\n                    snake.body.length - partIndex - 1,\n                    this.props.highlightedSnake\n                  )\n                )}\n            </g>\n          );\n        })}\n        {hazards.map((o, hazardIndex) => (\n          <rect\n            key={\"hazard\" + hazardIndex}\n            x={toGridSpaceX(o.x)}\n            y={toGridSpaceY(o.y)}\n            width={CELL_SIZE}\n            height={CELL_SIZE}\n            fill={colors.hazard}\n            fillOpacity={hazardOpacity}\n            shapeRendering=\"auto\"\n          />\n        ))}\n        {food.map((f, foodIndex) => {\n          if (this.props.foodImage) {\n            return (\n              <image\n                key={\"food\" + foodIndex}\n                x={toGridSpaceX(f.x)}\n                y={toGridSpaceY(f.y)}\n                width={CELL_SIZE}\n                height={CELL_SIZE}\n                href={this.props.foodImage}\n              />\n            );\n          } else {\n            return (\n              <circle\n                key={\"food\" + foodIndex}\n                className=\"food\"\n                cx={toGridSpaceX(f.x) + CELL_SIZE / 2}\n                cy={toGridSpaceY(f.y) + CELL_SIZE / 2}\n                r={FOOD_SIZE}\n                fill={colors.food}\n                shapeRendering=\"optimizeQuality\"\n              />\n            );\n          }\n        })}\n      </svg>\n    );\n  }\n\n  render() {\n    if (this.props.snakes) {\n      return this.renderGrid();\n    } else {\n      return;\n    }\n  }\n}\n\nexport default Grid;\n"]},"metadata":{},"sourceType":"module"}