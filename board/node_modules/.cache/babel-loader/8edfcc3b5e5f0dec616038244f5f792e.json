{"ast":null,"code":"// Creates a dictionary of parameters based on the given query string. q should\n// look like \"?foo=bar&thing=blah\".\nexport function parseQueryString(q) {\n  //ここでqは'?engine=https://tyr.ics.es.osaka-u.ac.jp/vcli&game=9991'となっている\n  //?engineからgame=まで固定なのでなくてもいいようにしよう\n  console.log(\"output url : \");\n  console.log(q);\n  const game_id = q.substr(1);\n  const args = [2];\n  args[0] = {\n    key: \"engine\",\n    value: \"https://tyr.ics.es.osaka-u.ac.jp/vcli\"\n  };\n  args[1] = {\n    key: \"game\",\n    value: game_id\n  };\n  console.log(\"args[0] ouput : \");\n  console.log(args[0]);\n  console.log(\"args[1] output : \");\n  console.log(args[1]); // Convert to object\n\n  return args.reduce((result, arg) => {\n    result[arg.key] = arg.value;\n    return result;\n  }, {});\n} // Converts { a: \"aaa\", b: \"bbb\" } to \"?a=aaa&b=bbb\"\n\nexport function makeQueryString(query) {\n  if (!query) {\n    return \"\";\n  }\n\n  let sep = \"?\";\n  let result = \"\";\n\n  for (const key in query) {\n    const value = query[key];\n    result += `${sep}${key}=${value}`;\n    sep = \"&\";\n  }\n\n  return result;\n} // Converts http://foo to ws://foo or https://foo to wss://foo\n\nexport function httpToWsProtocol(url) {\n  const mappings = {\n    http: \"ws\",\n    https: \"wss\"\n  };\n\n  for (const from in mappings) {\n    const to = mappings[from];\n\n    if (url.substr(0, from.length + 1) === from + \":\") {\n      return to + url.substr(from.length);\n    }\n  }\n\n  throw new Error(\"Invalid URL: \" + url);\n} // Joins path components and makes sure there is exactly one '/' separating\n// them.\n\nexport function join(...parts) {\n  function joinPair(a, b) {\n    const cleanA = a.replace(/\\/+$/, \"\");\n    const cleanB = b.replace(/^\\/+/, \"\");\n\n    if (cleanA === \"\") {\n      return cleanB;\n    }\n\n    if (cleanB === \"\") {\n      return cleanA;\n    }\n\n    return `${cleanA}/${cleanB}`;\n  }\n\n  return parts.reduce((current, next) => joinPair(current, next), \"\");\n}","map":{"version":3,"sources":["/home/yabust/CC/board/src/utils/url.js"],"names":["parseQueryString","q","console","log","game_id","substr","args","key","value","reduce","result","arg","makeQueryString","query","sep","httpToWsProtocol","url","mappings","http","https","from","to","length","Error","join","parts","joinPair","a","b","cleanA","replace","cleanB","current","next"],"mappings":"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","sourcesContent":["// Creates a dictionary of parameters based on the given query string. q should\n// look like \"?foo=bar&thing=blah\".\nexport function parseQueryString(q) {\n  //ここでqは'?engine=https://tyr.ics.es.osaka-u.ac.jp/vcli&game=9991'となっている\n  //?engineからgame=まで固定なのでなくてもいいようにしよう\n  console.log(\"output url : \");\n  console.log(q);\n  const game_id = q.substr(1);\n  const args = [2];\n  args[0] = { key: \"engine\", value: \"https://tyr.ics.es.osaka-u.ac.jp/vcli\" };\n  args[1] = { key: \"game\", value: game_id };\n  console.log(\"args[0] ouput : \");\n  console.log(args[0]);\n  console.log(\"args[1] output : \");\n  console.log(args[1]);\n  // Convert to object\n  return args.reduce((result, arg) => {\n    result[arg.key] = arg.value;\n    return result;\n  }, {});\n}\n// Converts { a: \"aaa\", b: \"bbb\" } to \"?a=aaa&b=bbb\"\nexport function makeQueryString(query) {\n  if (!query) {\n    return \"\";\n  }\n\n  let sep = \"?\";\n  let result = \"\";\n\n  for (const key in query) {\n    const value = query[key];\n    result += `${sep}${key}=${value}`;\n    sep = \"&\";\n  }\n  return result;\n}\n\n// Converts http://foo to ws://foo or https://foo to wss://foo\nexport function httpToWsProtocol(url) {\n  const mappings = {\n    http: \"ws\",\n    https: \"wss\"\n  };\n\n  for (const from in mappings) {\n    const to = mappings[from];\n    if (url.substr(0, from.length + 1) === from + \":\") {\n      return to + url.substr(from.length);\n    }\n  }\n\n  throw new Error(\"Invalid URL: \" + url);\n}\n\n// Joins path components and makes sure there is exactly one '/' separating\n// them.\nexport function join(...parts) {\n  function joinPair(a, b) {\n    const cleanA = a.replace(/\\/+$/, \"\");\n    const cleanB = b.replace(/^\\/+/, \"\");\n\n    if (cleanA === \"\") {\n      return cleanB;\n    }\n\n    if (cleanB === \"\") {\n      return cleanA;\n    }\n\n    return `${cleanA}/${cleanB}`;\n  }\n\n  return parts.reduce((current, next) => joinPair(current, next), \"\");\n}\n"]},"metadata":{},"sourceType":"module"}