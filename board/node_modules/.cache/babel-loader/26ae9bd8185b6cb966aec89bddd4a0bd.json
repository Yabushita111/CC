{"ast":null,"code":"// Creates a dictionary of parameters based on the given query string. q should\n// look like \"?foo=bar&thing=blah\".\nexport function parseQueryString(q) {\n  //ここでqは'?engine=https://tyr.ics.es.osaka-u.ac.jp/vcli&game=9991'となっている\n  //?engineからgame=まで固定なのでなくてもいいようにしよう\n  console.log(\"output url : \");\n  console.log(q);\n\n  if (!q || !q.length) {\n    return {};\n  } // Array of key/value pairs\n  //改変後はqは9991だけ\n  //argsの中身をargs[0] = {key: 'engine', value: 'https://tyr.ics.es.osaka-u.ac.jp/vcli}\n  //args[1] = {key: 'game', value: '9e4a1c38-d5fd-4ec1-b0f7-681647bd6900'} に変える\n  // const args = q\n  //   .substr(1)\n  //   .split(\"&\")\n  //   .map(parseArg);\n\n\n  const args = [2];\n  args[0] = {\n    key: \"engine\",\n    value: \"https://tyr.ics.es.osaka-u.ac.jp/vcli\"\n  };\n  args[1] = {\n    key: \"game\",\n    value: q\n  };\n  console.log(\"args[0] ouput : \");\n  console.log(args[0]);\n  console.log(\"args[1] output : \");\n  console.log(args[1]); // Convert to object\n\n  return args.reduce((result, arg) => {\n    result[arg.key] = arg.value;\n    return result;\n  }, {});\n} // Converts \"asdf=qwer\" to { asdf: \"qwer\" } or \"asdf\" to { asdf: true }. The\n// latter example is to allow switch-like parameters like ?enableThing without\n// an equals sign.\n\nfunction parseArg(a) {\n  const parts = a.split(\"=\");\n  console.log(\"patts[0] ouput : \");\n  console.log(parts[0]);\n  console.log(\"parts[1] output : \");\n  console.log(parts[1]);\n  const key = parts[0];\n  const value = parts[1] === undefined ? true : decodeURIComponent(parts[1]);\n  return {\n    key,\n    value\n  };\n} // Converts { a: \"aaa\", b: \"bbb\" } to \"?a=aaa&b=bbb\"\n\n\nexport function makeQueryString(query) {\n  if (!query) {\n    return \"\";\n  }\n\n  let sep = \"?\";\n  let result = \"\";\n\n  for (const key in query) {\n    const value = query[key];\n    result += `${sep}${key}=${value}`;\n    sep = \"&\";\n  }\n\n  return result;\n} // Converts http://foo to ws://foo or https://foo to wss://foo\n\nexport function httpToWsProtocol(url) {\n  const mappings = {\n    http: \"ws\",\n    https: \"wss\"\n  };\n\n  for (const from in mappings) {\n    const to = mappings[from];\n\n    if (url.substr(0, from.length + 1) === from + \":\") {\n      return to + url.substr(from.length);\n    }\n  }\n\n  throw new Error(\"Invalid URL: \" + url);\n} // Joins path components and makes sure there is exactly one '/' separating\n// them.\n\nexport function join(...parts) {\n  function joinPair(a, b) {\n    const cleanA = a.replace(/\\/+$/, \"\");\n    const cleanB = b.replace(/^\\/+/, \"\");\n\n    if (cleanA === \"\") {\n      return cleanB;\n    }\n\n    if (cleanB === \"\") {\n      return cleanA;\n    }\n\n    return `${cleanA}/${cleanB}`;\n  }\n\n  return parts.reduce((current, next) => joinPair(current, next), \"\");\n}","map":{"version":3,"sources":["/home/yabust/CC/board/src/utils/url.js"],"names":["parseQueryString","q","console","log","length","args","key","value","reduce","result","arg","parseArg","a","parts","split","undefined","decodeURIComponent","makeQueryString","query","sep","httpToWsProtocol","url","mappings","http","https","from","to","substr","Error","join","joinPair","b","cleanA","replace","cleanB","current","next"],"mappings":"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","sourcesContent":["// Creates a dictionary of parameters based on the given query string. q should\n// look like \"?foo=bar&thing=blah\".\nexport function parseQueryString(q) {\n  //ここでqは'?engine=https://tyr.ics.es.osaka-u.ac.jp/vcli&game=9991'となっている\n  //?engineからgame=まで固定なのでなくてもいいようにしよう\n  console.log(\"output url : \");\n  console.log(q);\n  if (!q || !q.length) {\n    return {};\n  }\n\n  // Array of key/value pairs\n  //改変後はqは9991だけ\n  //argsの中身をargs[0] = {key: 'engine', value: 'https://tyr.ics.es.osaka-u.ac.jp/vcli}\n  //args[1] = {key: 'game', value: '9e4a1c38-d5fd-4ec1-b0f7-681647bd6900'} に変える\n  // const args = q\n  //   .substr(1)\n  //   .split(\"&\")\n  //   .map(parseArg);\n  const args = [2];\n  args[0] = { key: \"engine\", value : \"https://tyr.ics.es.osaka-u.ac.jp/vcli\" };\n  args[1] = { key: \"game\", value : q};\n  console.log(\"args[0] ouput : \");\n  console.log(args[0]);\n  console.log(\"args[1] output : \");\n  console.log(args[1]);\n  // Convert to object\n  return args.reduce((result, arg) => {\n    result[arg.key] = arg.value;\n    return result;\n  }, {});\n}\n\n// Converts \"asdf=qwer\" to { asdf: \"qwer\" } or \"asdf\" to { asdf: true }. The\n// latter example is to allow switch-like parameters like ?enableThing without\n// an equals sign.\nfunction parseArg(a) {\n  const parts = a.split(\"=\");\n  console.log(\"patts[0] ouput : \");\n  console.log(parts[0]);\n  console.log(\"parts[1] output : \");\n  console.log(parts[1]);\n  const key = parts[0];\n  const value = parts[1] === undefined ? true : decodeURIComponent(parts[1]);\n  return { key, value };\n}\n\n// Converts { a: \"aaa\", b: \"bbb\" } to \"?a=aaa&b=bbb\"\nexport function makeQueryString(query) {\n  if (!query) {\n    return \"\";\n  }\n\n  let sep = \"?\";\n  let result = \"\";\n\n  for (const key in query) {\n    const value = query[key];\n    result += `${sep}${key}=${value}`;\n    sep = \"&\";\n  }\n  return result;\n}\n\n// Converts http://foo to ws://foo or https://foo to wss://foo\nexport function httpToWsProtocol(url) {\n  const mappings = {\n    http: \"ws\",\n    https: \"wss\"\n  };\n\n  for (const from in mappings) {\n    const to = mappings[from];\n    if (url.substr(0, from.length + 1) === from + \":\") {\n      return to + url.substr(from.length);\n    }\n  }\n\n  throw new Error(\"Invalid URL: \" + url);\n}\n\n// Joins path components and makes sure there is exactly one '/' separating\n// them.\nexport function join(...parts) {\n  function joinPair(a, b) {\n    const cleanA = a.replace(/\\/+$/, \"\");\n    const cleanB = b.replace(/^\\/+/, \"\");\n\n    if (cleanA === \"\") {\n      return cleanB;\n    }\n\n    if (cleanB === \"\") {\n      return cleanA;\n    }\n\n    return `${cleanA}/${cleanB}`;\n  }\n\n  return parts.reduce((current, next) => joinPair(current, next), \"\");\n}\n"]},"metadata":{},"sourceType":"module"}